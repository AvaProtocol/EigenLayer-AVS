{
  "pr_number": "439",
  "repository": "AvaProtocol/EigenLayer-AVS",
  "copilot": {
    "review_comments": [
      {
        "id": "PRRC_kwDOLqYZns6fmxfA",
        "path": "core/taskengine/engine.go",
        "line": 286,
        "diff_hunk": "@@ -275,9 +275,22 @@ func New(db storage.Storage, config *config.Config, queue *apqueue.Queue, logger\n \t}\n \n \t// Initialize optional AI summarizer (global) from aggregator config\n-\tif s := NewOpenAISummarizerFromAggregatorConfig(config); s != nil {\n+\tvar s Summarizer\n+\tswitch strings.ToLower(config.NotificationsSummary.Provider) {\n+\tcase \"openai\":\n+\t\ts = NewOpenAISummarizerFromAggregatorConfig(config)\n+\tcase \"context-memory\":\n+\t\ts = NewContextMemorySummarizerFromAggregatorConfig(config)\n+\tdefault:\n+\t\ts = nil\n+\t}",
        "body": "The provider comparison logic is case-insensitive in engine.go (line 279: `strings.ToLower(config.NotificationsSummary.Provider)`), but the factory functions check for exact lowercase matches. If the configuration contains mixed case like \"Context-Memory\" or \"OpenAI\", the factory functions `NewOpenAISummarizerFromAggregatorConfig` (line 153 in summarizer_ai.go) and `NewContextMemorySummarizerFromAggregatorConfig` (line 153 in summarizer_ai.go) will fail to match and return nil. Ensure consistent case handling or document the exact required provider names.",
        "created_at": "2026-01-09T22:02:04Z",
        "user": "copilot-pull-request-reviewer"
      },
      {
        "id": "PRRC_kwDOLqYZns6fmxfN",
        "path": "core/taskengine/summarizer.go",
        "line": 1246,
        "diff_hunk": "@@ -1143,12 +1203,48 @@ func getTotalWorkflowSteps(vm *VM) int {\n \tvm.mu.Lock()\n \tdefer vm.mu.Unlock()\n \n-\t// Count: 1 trigger + all nodes in TaskNodes\n-\ttotalSteps := 1 + len(vm.TaskNodes)\n+\t// Count all nodes, excluding notification nodes (email/telegram REST API)\n+\tnodeCount := 0\n+\tfor _, node := range vm.TaskNodes {\n+\t\tif node == nil {\n+\t\t\tcontinue\n+\t\t}\n+\t\t// Check if this is a notification node (REST API with sendgrid/telegram URL)\n+\t\tif isNotificationNode(node) {\n+\t\t\tcontinue\n+\t\t}\n+\t\tnodeCount++\n+\t}\n+\n+\t// Count: 1 trigger + non-notification nodes\n+\ttotalSteps := 1 + nodeCount\n \n \treturn totalSteps\n }\n \n+// isNotificationNode checks if a task node is a notification endpoint (email/telegram)\n+func isNotificationNode(node *avsproto.TaskNode) bool {\n+\tif node == nil {\n+\t\treturn false\n+\t}\n+\t// Check if it's a REST API node\n+\trestAPI := node.GetRestApi()\n+\tif restAPI == nil || restAPI.Config == nil {\n+\t\treturn false\n+\t}\n+\t// Check URL for notification providers\n+\turl := strings.ToLower(restAPI.Config.Url)\n+\t// SendGrid\n+\tif strings.Contains(url, \"sendgrid\") || strings.Contains(url, \"/mail/send\") {\n+\t\treturn true\n+\t}\n+\t// Telegram\n+\tif strings.Contains(url, \"telegram\") || strings.Contains(url, \"api.telegram.org\") {\n+\t\treturn true\n+\t}\n+\treturn false\n+}",
        "body": "Notification nodes are excluded from total step count but the determination logic may be too broad. The function `isNotificationNode` checks if the URL contains \"sendgrid\", \"mail/send\", \"telegram\", or \"api.telegram.org\" (lines 1236-1242). This could incorrectly classify legitimate API nodes that happen to interact with these services. For example, a workflow that queries Telegram API for data (not sending notifications) would be excluded. Consider adding additional checks like HTTP method (POST for notifications) or checking for specific notification-related fields in the node configuration.",
        "created_at": "2026-01-09T22:02:04Z",
        "user": "copilot-pull-request-reviewer"
      },
      {
        "id": "PRRC_kwDOLqYZns6fmxfY",
        "path": "core/taskengine/summarizer_context_memory_integration_test.go",
        "line": 568,
        "diff_hunk": "@@ -0,0 +1,602 @@\n+//go:build integration\n+// +build integration\n+\n+package taskengine\n+\n+import (\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"strings\"\n+\t\"testing\"\n+\t\"time\"\n+\n+\tavsproto \"github.com/AvaProtocol/EigenLayer-AVS/protobuf\"\n+\t\"github.com/go-resty/resty/v2\"\n+)\n+\n+// ExecutionSummaryResponse matches the TypeScript ExecutionSummaryResponse interface\n+type ExecutionSummaryResponse struct {\n+\tStatus        string   `json:\"status\"`        // 'success' | 'partial_success' | 'failure'\n+\tBranchSummary string   `json:\"branchSummary\"` // Plain text summary\n+\tSkippedNodes  []string `json:\"skippedNodes\"`  // Array of skipped node names\n+\tTotalSteps    int      `json:\"totalSteps\"`    // Total steps in workflow\n+\tExecutedSteps int      `json:\"executedSteps\"` // Number of steps executed\n+\tSkippedSteps  int      `json:\"skippedSteps\"`  // Number of skipped steps\n+}\n+\n+// SummarizeRequest matches the TypeScript SummarizeRequest interface\n+type SummarizeRequest struct {\n+\tOwnerEOA        string                 `json:\"ownerEOA\"`\n+\tName            string                 `json:\"name\"`\n+\tSmartWallet     string                 `json:\"smartWallet\"`\n+\tSteps           []StepDigest           `json:\"steps\"`\n+\tChainName       string                 `json:\"chainName,omitempty\"`\n+\tNodes           []NodeDefinition       `json:\"nodes,omitempty\"`\n+\tEdges           []EdgeDefinition       `json:\"edges,omitempty\"`\n+\tSettings        map[string]interface{} `json:\"settings,omitempty\"`\n+\tCurrentNodeName string                 `json:\"currentNodeName,omitempty\"`\n+}\n+\n+type StepDigest struct {\n+\tName            string                 `json:\"name\"`\n+\tID              string                 `json:\"id\"`\n+\tType            string                 `json:\"type\"`\n+\tSuccess         bool                   `json:\"success\"`\n+\tError           string                 `json:\"error,omitempty\"`\n+\tContractAddress string                 `json:\"contractAddress,omitempty\"`\n+\tMethodName      string                 `json:\"methodName,omitempty\"`\n+\tMethodParams    map[string]interface{} `json:\"methodParams,omitempty\"`\n+\tOutputData      interface{}            `json:\"outputData,omitempty\"`\n+\tMetadata        interface{}            `json:\"metadata,omitempty\"`\n+\tStepDescription string                 `json:\"stepDescription,omitempty\"`\n+}\n+\n+type NodeDefinition struct {\n+\tID   string `json:\"id\"`\n+\tName string `json:\"name\"`\n+}\n+\n+type EdgeDefinition struct {\n+\tID     string `json:\"id\"`\n+\tSource string `json:\"source\"`\n+\tTarget string `json:\"target\"`\n+}\n+\n+// getContextMemoryURL returns the base URL for context-memory API\n+// Uses CONTEXT_MEMORY_URL env var if set, otherwise defaults to production URL from source code\n+func getContextMemoryURL() string {\n+\tif url := os.Getenv(\"CONTEXT_MEMORY_URL\"); url != \"\" {\n+\t\treturn url\n+\t}\n+\treturn ContextAPIURL\n+}\n+\n+// baseURL shared across tests to avoid redeclaration issues\n+var baseURL string\n+\n+func TestContextMemoryExecutionSummary_SuccessfulWorkflow(t *testing.T) {\n+\tbaseURL = getContextMemoryURL()\n+\tauthToken := getAuthTokenOrSkip(t, baseURL)\n+\tt.Logf(\"Testing against: %s\", baseURL)\n+\n+\tclient := resty.New()\n+\tclient.SetTimeout(30 * time.Second)\n+\n+\t// Build request from VM-like structure\n+\trequest := SummarizeRequest{\n+\t\tOwnerEOA:    \"0xc60e71bd0f2e6d8832Fea1a2d56091C48493C788\",\n+\t\tName:        \"Test Workflow\",\n+\t\tSmartWallet: \"0xeCb88a770e1b2Ba303D0dC3B1c6F239fAB014bAE\",\n+\t\tChainName:   \"Sepolia\",\n+\t\tSteps: []StepDigest{\n+\t\t\t{\n+\t\t\t\tName:    \"balance1\",\n+\t\t\t\tID:      \"step1\",\n+\t\t\t\tType:    \"balance\",\n+\t\t\t\tSuccess: true,\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tName:            \"approve_token1\",\n+\t\t\t\tID:              \"step2\",\n+\t\t\t\tType:            \"contractWrite\",\n+\t\t\t\tSuccess:         true,\n+\t\t\t\tContractAddress: \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\",\n+\t\t\t\tMethodName:      \"approve\",\n+\t\t\t\tStepDescription: \"Approved 1000 USDC to Uniswap V3 router\",\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tName:    \"get_quote\",\n+\t\t\t\tID:      \"step3\",\n+\t\t\t\tType:    \"contractRead\",\n+\t\t\t\tSuccess: true,\n+\t\t\t},\n+\t\t},\n+\t\tNodes: []NodeDefinition{\n+\t\t\t{ID: \"node1\", Name: \"balance1\"},\n+\t\t\t{ID: \"node2\", Name: \"approve_token1\"},\n+\t\t\t{ID: \"node3\", Name: \"get_quote\"},\n+\t\t\t{ID: \"node4\", Name: \"run_swap\"},\n+\t\t},\n+\t\tEdges: []EdgeDefinition{\n+\t\t\t{ID: \"edge1\", Source: \"node1\", Target: \"node2\"},\n+\t\t\t{ID: \"edge2\", Source: \"node2\", Target: \"node3\"},\n+\t\t\t{ID: \"edge3\", Source: \"node3\", Target: \"node4\"},\n+\t\t},\n+\t}\n+\n+\tvar response ExecutionSummaryResponse\n+\turl := baseURL + \"/api/execution-summary\"\n+\n+\t// Log request details for debugging\n+\tt.Logf(\"Making POST request to: %s\", url)\n+\tt.Logf(\"Request body (first 500 chars): %s\", truncateString(mustMarshalJSON(request), 500))\n+\n+\tresp, err := client.R().\n+\t\tSetHeader(\"Authorization\", \"Bearer \"+authToken).\n+\t\tSetHeader(\"Content-Type\", \"application/json\").\n+\t\tSetBody(request).\n+\t\tSetResult(&response).\n+\t\tPost(url)\n+\n+\tif err != nil {\n+\t\tt.Fatalf(\"HTTP request failed: %v\", err)\n+\t}\n+\n+\tif resp.StatusCode() != 200 {\n+\t\tt.Logf(\"Response status: %d\", resp.StatusCode())\n+\t\tt.Logf(\"Response headers: %v\", resp.Header())\n+\t\tt.Logf(\"Full response body: %s\", string(resp.Body()))\n+\t\tt.Fatalf(\"Expected status 200, got %d. Response body: %s\", resp.StatusCode(), string(resp.Body()))\n+\t}\n+\n+\tt.Logf(\"Success! Response: status=%s, executedSteps=%d, totalSteps=%d\",\n+\t\tresponse.Status, response.ExecutedSteps, response.TotalSteps)\n+\n+\t// Validate response structure\n+\tif response.Status == \"\" {\n+\t\tt.Error(\"Response status should not be empty\")\n+\t}\n+\tif response.Status != \"success\" && response.Status != \"partial_success\" && response.Status != \"failure\" {\n+\t\tt.Errorf(\"Invalid status value: %s (expected 'success', 'partial_success', or 'failure')\", response.Status)\n+\t}\n+\n+\t// branchSummary should always be present (even if empty string)\n+\tif response.BranchSummary == \"\" {\n+\t\t// Empty string is valid when there are no skipped nodes\n+\t\tt.Log(\"branchSummary is empty (expected for successful workflow)\")\n+\t}\n+\n+\t// skippedNodes should always be present (even if empty array)\n+\tif response.SkippedNodes == nil {\n+\t\tt.Error(\"skippedNodes should not be nil\")\n+\t}\n+\n+\t// Validate metrics\n+\tif response.ExecutedSteps != 3 {\n+\t\tt.Errorf(\"Expected executedSteps=3, got %d\", response.ExecutedSteps)\n+\t}\n+\tif response.TotalSteps < response.ExecutedSteps {\n+\t\tt.Errorf(\"totalSteps (%d) should be >= executedSteps (%d)\", response.TotalSteps, response.ExecutedSteps)\n+\t}\n+\tif response.SkippedSteps < 0 {\n+\t\tt.Errorf(\"skippedSteps should be >= 0, got %d\", response.SkippedSteps)\n+\t}\n+\n+\t// For this test, we expect 1 skipped node (run_swap)\n+\tif response.SkippedSteps != 1 {\n+\t\tt.Errorf(\"Expected skippedSteps=1 (run_swap was skipped), got %d\", response.SkippedSteps)\n+\t}\n+\tif len(response.SkippedNodes) != 1 {\n+\t\tt.Errorf(\"Expected 1 skipped node, got %d: %v\", len(response.SkippedNodes), response.SkippedNodes)\n+\t}\n+\tif len(response.SkippedNodes) > 0 && response.SkippedNodes[0] != \"run_swap\" {\n+\t\tt.Errorf(\"Expected skipped node 'run_swap', got %s\", response.SkippedNodes[0])\n+\t}\n+\n+\tt.Logf(\"Response: status=%s, executedSteps=%d, totalSteps=%d, skippedSteps=%d, skippedNodes=%v\",\n+\t\tresponse.Status, response.ExecutedSteps, response.TotalSteps, response.SkippedSteps, response.SkippedNodes)\n+}\n+\n+func TestContextMemoryExecutionSummary_FailedWorkflow(t *testing.T) {\n+\tbaseURL = getContextMemoryURL()\n+\tauthToken := getAuthTokenOrSkip(t, baseURL)\n+\n+\tclient := resty.New()\n+\tclient.SetTimeout(30 * time.Second)\n+\n+\trequest := SummarizeRequest{\n+\t\tOwnerEOA:    \"0xc60e71bd0f2e6d8832Fea1a2d56091C48493C788\",\n+\t\tName:        \"Failed Workflow\",\n+\t\tSmartWallet: \"0xeCb88a770e1b2Ba303D0dC3B1c6F239fAB014bAE\",\n+\t\tChainName:   \"Sepolia\",\n+\t\tSteps: []StepDigest{\n+\t\t\t{\n+\t\t\t\tName:    \"approve_token\",\n+\t\t\t\tID:      \"step1\",\n+\t\t\t\tType:    \"contractWrite\",\n+\t\t\t\tSuccess: true,\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tName:    \"swap_tokens\",\n+\t\t\t\tID:      \"step2\",\n+\t\t\t\tType:    \"contractWrite\",\n+\t\t\t\tSuccess: false,\n+\t\t\t\tError:   \"Insufficient gas\",\n+\t\t\t},\n+\t\t},\n+\t\tNodes: []NodeDefinition{\n+\t\t\t{ID: \"node1\", Name: \"approve_token\"},\n+\t\t\t{ID: \"node2\", Name: \"swap_tokens\"},\n+\t\t},\n+\t}\n+\n+\tvar response ExecutionSummaryResponse\n+\turl := baseURL + \"/api/execution-summary\"\n+\n+\t// Log request details for debugging\n+\tt.Logf(\"Making POST request to: %s\", url)\n+\tt.Logf(\"Request body (first 500 chars): %s\", truncateString(mustMarshalJSON(request), 500))\n+\n+\tresp, err := client.R().\n+\t\tSetHeader(\"Authorization\", \"Bearer \"+authToken).\n+\t\tSetHeader(\"Content-Type\", \"application/json\").\n+\t\tSetBody(request).\n+\t\tSetResult(&response).\n+\t\tPost(url)\n+\n+\tif err != nil {\n+\t\tt.Fatalf(\"HTTP request failed: %v\", err)\n+\t}\n+\n+\tif resp.StatusCode() != 200 {\n+\t\tt.Logf(\"Response status: %d\", resp.StatusCode())\n+\t\tt.Logf(\"Response headers: %v\", resp.Header())\n+\t\tt.Logf(\"Full response body: %s\", string(resp.Body()))\n+\t\tt.Fatalf(\"Expected status 200, got %d. Response body: %s\", resp.StatusCode(), string(resp.Body()))\n+\t}\n+\n+\tt.Logf(\"Success! Response: status=%s, executedSteps=%d, totalSteps=%d\",\n+\t\tresponse.Status, response.ExecutedSteps, response.TotalSteps)\n+\n+\t// Validate failure status\n+\tif response.Status != \"failure\" {\n+\t\tt.Errorf(\"Expected status='failure', got %s\", response.Status)\n+\t}\n+\n+\t// Validate metrics\n+\tif response.ExecutedSteps != 2 {\n+\t\tt.Errorf(\"Expected executedSteps=2, got %d\", response.ExecutedSteps)\n+\t}\n+\n+\tt.Logf(\"Failed workflow response: status=%s, executedSteps=%d\", response.Status, response.ExecutedSteps)\n+}\n+\n+func TestContextMemoryExecutionSummary_CompleteWorkflow(t *testing.T) {\n+\tbaseURL = getContextMemoryURL()\n+\tauthToken := getAuthTokenOrSkip(t, baseURL)\n+\n+\tclient := resty.New()\n+\tclient.SetTimeout(30 * time.Second)\n+\n+\trequest := SummarizeRequest{\n+\t\tOwnerEOA:    \"0xc60e71bd0f2e6d8832Fea1a2d56091C48493C788\",\n+\t\tName:        \"Complete Workflow\",\n+\t\tSmartWallet: \"0xeCb88a770e1b2Ba303D0dC3B1c6F239fAB014bAE\",\n+\t\tChainName:   \"Sepolia\",\n+\t\tSteps: []StepDigest{\n+\t\t\t{\n+\t\t\t\tName:    \"balance1\",\n+\t\t\t\tID:      \"step1\",\n+\t\t\t\tType:    \"balance\",\n+\t\t\t\tSuccess: true,\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tName:    \"approve_token1\",\n+\t\t\t\tID:      \"step2\",\n+\t\t\t\tType:    \"contractWrite\",\n+\t\t\t\tSuccess: true,\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tName:    \"get_quote\",\n+\t\t\t\tID:      \"step3\",\n+\t\t\t\tType:    \"contractRead\",\n+\t\t\t\tSuccess: true,\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tName:    \"run_swap\",\n+\t\t\t\tID:      \"step4\",\n+\t\t\t\tType:    \"contractWrite\",\n+\t\t\t\tSuccess: true,\n+\t\t\t},\n+\t\t},\n+\t\tNodes: []NodeDefinition{\n+\t\t\t{ID: \"node1\", Name: \"balance1\"},\n+\t\t\t{ID: \"node2\", Name: \"approve_token1\"},\n+\t\t\t{ID: \"node3\", Name: \"get_quote\"},\n+\t\t\t{ID: \"node4\", Name: \"run_swap\"},\n+\t\t},\n+\t}\n+\n+\tvar response ExecutionSummaryResponse\n+\turl := baseURL + \"/api/execution-summary\"\n+\n+\t// Log request details for debugging\n+\tt.Logf(\"Making POST request to: %s\", url)\n+\tt.Logf(\"Request body (first 500 chars): %s\", truncateString(mustMarshalJSON(request), 500))\n+\n+\tresp, err := client.R().\n+\t\tSetHeader(\"Authorization\", \"Bearer \"+authToken).\n+\t\tSetHeader(\"Content-Type\", \"application/json\").\n+\t\tSetBody(request).\n+\t\tSetResult(&response).\n+\t\tPost(url)\n+\n+\tif err != nil {\n+\t\tt.Fatalf(\"HTTP request failed: %v\", err)\n+\t}\n+\n+\tif resp.StatusCode() != 200 {\n+\t\tt.Logf(\"Response status: %d\", resp.StatusCode())\n+\t\tt.Logf(\"Response headers: %v\", resp.Header())\n+\t\tt.Logf(\"Full response body: %s\", string(resp.Body()))\n+\t\tt.Fatalf(\"Expected status 200, got %d. Response body: %s\", resp.StatusCode(), string(resp.Body()))\n+\t}\n+\n+\tt.Logf(\"Success! Response: status=%s, executedSteps=%d, totalSteps=%d\",\n+\t\tresponse.Status, response.ExecutedSteps, response.TotalSteps)\n+\n+\t// Validate success status\n+\tif response.Status != \"success\" {\n+\t\tt.Errorf(\"Expected status='success', got %s\", response.Status)\n+\t}\n+\n+\t// All nodes executed, no skipped nodes\n+\tif response.SkippedSteps != 0 {\n+\t\tt.Errorf(\"Expected skippedSteps=0, got %d\", response.SkippedSteps)\n+\t}\n+\tif len(response.SkippedNodes) != 0 {\n+\t\tt.Errorf(\"Expected no skipped nodes, got %v\", response.SkippedNodes)\n+\t}\n+\tif response.ExecutedSteps != 4 {\n+\t\tt.Errorf(\"Expected executedSteps=4, got %d\", response.ExecutedSteps)\n+\t}\n+\tif response.TotalSteps != 4 {\n+\t\tt.Errorf(\"Expected totalSteps=4, got %d\", response.TotalSteps)\n+\t}\n+\n+\tt.Logf(\"Complete workflow response: status=%s, executedSteps=%d, totalSteps=%d\",\n+\t\tresponse.Status, response.ExecutedSteps, response.TotalSteps)\n+}\n+\n+func TestContextMemoryExecutionSummary_FromVM(t *testing.T) {\n+\tbaseURL = getContextMemoryURL()\n+\tauthToken := getAuthTokenOrSkip(t, baseURL)\n+\t// Create a VM similar to TestComposeSummarySmart_WithRealWorkflowState\n+\tvm := NewVM()\n+\tvm.TaskID = \"01K6H8R583M8WFXM2Z4APP7JTN\"\n+\n+\tvm.ExecutionLogs = []*avsproto.Execution_Step{\n+\t\t{Id: \"trigger\", Name: \"eventTrigger\", Type: \"eventTrigger\", Success: true},\n+\t\t{Id: \"step1\", Name: \"balance1\", Type: \"balance\", Success: true},\n+\t\t{Id: \"step2\", Name: \"branch1\", Type: \"branch\", Success: true},\n+\t\t{Id: \"step3\", Name: \"email_report\", Type: \"restApi\", Success: true},\n+\t}\n+\n+\tvm.mu.Lock()\n+\tvm.TaskNodes = map[string]*avsproto.TaskNode{\n+\t\t\"node1\": {Id: \"node1\", Name: \"balance1\"},\n+\t\t\"node2\": {Id: \"node2\", Name: \"branch1\"},\n+\t\t\"node3\": {Id: \"node3\", Name: \"approve_token1\"},\n+\t\t\"node4\": {Id: \"node4\", Name: \"get_quote\"},\n+\t\t\"node5\": {Id: \"node5\", Name: \"run_swap\"},\n+\t\t\"node6\": {Id: \"node6\", Name: \"email_report\"},\n+\t}\n+\tvm.vars = map[string]interface{}{\n+\t\t\"settings\": map[string]interface{}{\n+\t\t\t\"name\":   \"Test template\",\n+\t\t\t\"chain\":  \"Sepolia\",\n+\t\t\t\"runner\": \"0xeCb88a770e1b2Ba303D0dC3B1c6F239fAB014bAE\",\n+\t\t},\n+\t\tWorkflowContextVarName: map[string]interface{}{\n+\t\t\t\"name\":   \"Test template\",\n+\t\t\t\"runner\": \"0xeCb88a770e1b2Ba303D0dC3B1c6F239fAB014bAE\",\n+\t\t\t\"owner\":  \"0xc60e71bd0f2e6d8832Fea1a2d56091C48493C788\",\n+\t\t},\n+\t}\n+\tvm.mu.Unlock()\n+\n+\t// Convert VM to API request\n+\t// Note: buildSummarizeRequestFromVM locks vm.mu, so we call it before creating the client\n+\trequest := buildSummarizeRequestFromVM(vm)\n+\n+\tbaseURL = getContextMemoryURL()\n+\tt.Logf(\"Testing against: %s\", baseURL)\n+\n+\tclient := resty.New()\n+\tclient.SetTimeout(30 * time.Second)\n+\n+\tvar response ExecutionSummaryResponse\n+\turl := baseURL + \"/api/execution-summary\"\n+\n+\t// Log request details for debugging\n+\tt.Logf(\"Making POST request to: %s\", url)\n+\tt.Logf(\"Request body (first 500 chars): %s\", truncateString(mustMarshalJSON(request), 500))\n+\n+\tresp, err := client.R().\n+\t\tSetHeader(\"Authorization\", \"Bearer \"+authToken).\n+\t\tSetHeader(\"Content-Type\", \"application/json\").\n+\t\tSetBody(request).\n+\t\tSetResult(&response).\n+\t\tPost(url)\n+\n+\tif err != nil {\n+\t\tt.Fatalf(\"HTTP request failed: %v\", err)\n+\t}\n+\n+\tif resp.StatusCode() != 200 {\n+\t\tt.Logf(\"Response status: %d\", resp.StatusCode())\n+\t\tt.Logf(\"Response headers: %v\", resp.Header())\n+\t\tt.Logf(\"Full response body: %s\", string(resp.Body()))\n+\t\tt.Fatalf(\"Expected status 200, got %d. Response body: %s\", resp.StatusCode(), string(resp.Body()))\n+\t}\n+\n+\tt.Logf(\"Success! Response: status=%s, executedSteps=%d, totalSteps=%d\",\n+\t\tresponse.Status, response.ExecutedSteps, response.TotalSteps)\n+\n+\t// Validate response\n+\tif response.Status == \"\" {\n+\t\tt.Error(\"Response status should not be empty\")\n+\t}\n+\n+\t// Should have 4 executed steps (trigger + 3 nodes)\n+\tif response.ExecutedSteps != 4 {\n+\t\tt.Errorf(\"Expected executedSteps=4, got %d\", response.ExecutedSteps)\n+\t}\n+\n+\t// Should have 3 skipped nodes (approve_token1, get_quote, run_swap)\n+\tif response.SkippedSteps != 3 {\n+\t\tt.Errorf(\"Expected skippedSteps=3, got %d\", response.SkippedSteps)\n+\t}\n+\tif response.TotalSteps != 7 {\n+\t\tt.Errorf(\"Expected totalSteps=7 (4 executed + 3 skipped), got %d\", response.TotalSteps)\n+\t}\n+\n+\t// Validate skipped nodes\n+\texpectedSkipped := []string{\"approve_token1\", \"get_quote\", \"run_swap\"}\n+\tif len(response.SkippedNodes) != len(expectedSkipped) {\n+\t\tt.Errorf(\"Expected %d skipped nodes, got %d: %v\", len(expectedSkipped), len(response.SkippedNodes), response.SkippedNodes)\n+\t}\n+\n+\t// branchSummary should contain text about skipped nodes\n+\tif response.BranchSummary == \"\" {\n+\t\tt.Error(\"branchSummary should not be empty when there are skipped nodes\")\n+\t}\n+\tif !strings.Contains(response.BranchSummary, \"skipped\") {\n+\t\tt.Errorf(\"branchSummary should mention skipped nodes, got: %s\", response.BranchSummary)\n+\t}\n+\n+\tt.Logf(\"VM-based test response: status=%s, executedSteps=%d, totalSteps=%d, skippedSteps=%d, skippedNodes=%v\",\n+\t\tresponse.Status, response.ExecutedSteps, response.TotalSteps, response.SkippedSteps, response.SkippedNodes)\n+\tt.Logf(\"branchSummary: %s\", response.BranchSummary)\n+}\n+\n+// buildSummarizeRequestFromVM converts a VM to a SummarizeRequest\n+// This mimics what the aggregator will do when integrating with context-memory\n+func buildSummarizeRequestFromVM(vm *VM) SummarizeRequest {\n+\tvm.mu.Lock()\n+\tdefer vm.mu.Unlock()\n+\n+\t// Extract workflow context\n+\tvar ownerEOA, smartWallet, workflowName, chainName string\n+\tif wfCtx, ok := vm.vars[WorkflowContextVarName].(map[string]interface{}); ok {\n+\t\tif owner, ok := wfCtx[\"owner\"].(string); ok {\n+\t\t\townerEOA = owner\n+\t\t}\n+\t\tif runner, ok := wfCtx[\"runner\"].(string); ok {\n+\t\t\tsmartWallet = runner\n+\t\t}\n+\t\tif name, ok := wfCtx[\"name\"].(string); ok {\n+\t\t\tworkflowName = name\n+\t\t}\n+\t}\n+\tif settings, ok := vm.vars[\"settings\"].(map[string]interface{}); ok {\n+\t\tif name, ok := settings[\"name\"].(string); ok && workflowName == \"\" {\n+\t\t\tworkflowName = name\n+\t\t}\n+\t\tif chain, ok := settings[\"chain\"].(string); ok {\n+\t\t\tchainName = chain\n+\t\t}\n+\t\tif runner, ok := settings[\"runner\"].(string); ok && smartWallet == \"\" {\n+\t\t\tsmartWallet = runner\n+\t\t}\n+\t}\n+\n+\t// Convert execution logs to steps\n+\tsteps := make([]StepDigest, 0, len(vm.ExecutionLogs))\n+\tfor _, log := range vm.ExecutionLogs {\n+\t\tstep := StepDigest{\n+\t\t\tName:    log.GetName(),\n+\t\t\tID:      log.GetId(),\n+\t\t\tType:    log.GetType(),\n+\t\t\tSuccess: log.GetSuccess(),\n+\t\t}\n+\t\tif log.GetError() != \"\" {\n+\t\t\tstep.Error = log.GetError()\n+\t\t}\n+\t\tsteps = append(steps, step)\n+\t}\n+\n+\t// Convert TaskNodes to nodes\n+\tnodes := make([]NodeDefinition, 0, len(vm.TaskNodes))\n+\tfor nodeID, node := range vm.TaskNodes {\n+\t\tif node == nil {\n+\t\t\tcontinue\n+\t\t}\n+\t\t// Skip branch condition pseudo-nodes\n+\t\tif strings.Contains(nodeID, \".\") {\n+\t\t\tcontinue\n+\t\t}\n+\t\tnodes = append(nodes, NodeDefinition{\n+\t\t\tID:   nodeID,\n+\t\t\tName: node.GetName(),\n+\t\t})\n+\t}\n+\n+\t// Convert edges (if available)\n+\t// Note: vm.task is a *model.Task which contains the protobuf Task\n+\tedges := make([]EdgeDefinition, 0)\n+\tif vm.task != nil && vm.task.Task != nil && vm.task.Task.Edges != nil {\n+\t\tfor _, edge := range vm.task.Task.Edges {\n+\t\t\tedges = append(edges, EdgeDefinition{\n+\t\t\t\tID:     edge.GetId(),\n+\t\t\t\tSource: edge.GetSource(),\n+\t\t\t\tTarget: edge.GetTarget(),\n+\t\t\t})\n+\t\t}\n+\t}\n+\n+\treturn SummarizeRequest{\n+\t\tOwnerEOA:    ownerEOA,\n+\t\tName:        workflowName,\n+\t\tSmartWallet: smartWallet,\n+\t\tSteps:       steps,\n+\t\tChainName:   chainName,\n+\t\tNodes:       nodes,\n+\t\tEdges:       edges,\n+\t}\n+}",
        "body": "Duplicate code between `buildSummarizeRequestFromVM` in the integration test and `buildRequest` method in `summarizer_context_memory.go`. The integration test version (lines 486-568) and the production code version (lines 149-280 in summarizer_context_memory.go) implement nearly identical logic for extracting workflow context and converting VM data to API request format. This duplication makes maintenance harder and could lead to inconsistencies if one is updated but not the other. Consider extracting this logic to a shared helper function or making the production `buildRequest` method accessible for testing.",
        "created_at": "2026-01-09T22:02:05Z",
        "user": "copilot-pull-request-reviewer"
      },
      {
        "id": "PRRC_kwDOLqYZns6fmxfe",
        "path": "core/taskengine/summarizer_context_memory_integration_test.go",
        "line": 537,
        "diff_hunk": "@@ -0,0 +1,602 @@\n+//go:build integration\n+// +build integration\n+\n+package taskengine\n+\n+import (\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"strings\"\n+\t\"testing\"\n+\t\"time\"\n+\n+\tavsproto \"github.com/AvaProtocol/EigenLayer-AVS/protobuf\"\n+\t\"github.com/go-resty/resty/v2\"\n+)\n+\n+// ExecutionSummaryResponse matches the TypeScript ExecutionSummaryResponse interface\n+type ExecutionSummaryResponse struct {\n+\tStatus        string   `json:\"status\"`        // 'success' | 'partial_success' | 'failure'\n+\tBranchSummary string   `json:\"branchSummary\"` // Plain text summary\n+\tSkippedNodes  []string `json:\"skippedNodes\"`  // Array of skipped node names\n+\tTotalSteps    int      `json:\"totalSteps\"`    // Total steps in workflow\n+\tExecutedSteps int      `json:\"executedSteps\"` // Number of steps executed\n+\tSkippedSteps  int      `json:\"skippedSteps\"`  // Number of skipped steps\n+}\n+\n+// SummarizeRequest matches the TypeScript SummarizeRequest interface\n+type SummarizeRequest struct {\n+\tOwnerEOA        string                 `json:\"ownerEOA\"`\n+\tName            string                 `json:\"name\"`\n+\tSmartWallet     string                 `json:\"smartWallet\"`\n+\tSteps           []StepDigest           `json:\"steps\"`\n+\tChainName       string                 `json:\"chainName,omitempty\"`\n+\tNodes           []NodeDefinition       `json:\"nodes,omitempty\"`\n+\tEdges           []EdgeDefinition       `json:\"edges,omitempty\"`\n+\tSettings        map[string]interface{} `json:\"settings,omitempty\"`\n+\tCurrentNodeName string                 `json:\"currentNodeName,omitempty\"`\n+}\n+\n+type StepDigest struct {\n+\tName            string                 `json:\"name\"`\n+\tID              string                 `json:\"id\"`\n+\tType            string                 `json:\"type\"`\n+\tSuccess         bool                   `json:\"success\"`\n+\tError           string                 `json:\"error,omitempty\"`\n+\tContractAddress string                 `json:\"contractAddress,omitempty\"`\n+\tMethodName      string                 `json:\"methodName,omitempty\"`\n+\tMethodParams    map[string]interface{} `json:\"methodParams,omitempty\"`\n+\tOutputData      interface{}            `json:\"outputData,omitempty\"`\n+\tMetadata        interface{}            `json:\"metadata,omitempty\"`\n+\tStepDescription string                 `json:\"stepDescription,omitempty\"`\n+}\n+\n+type NodeDefinition struct {\n+\tID   string `json:\"id\"`\n+\tName string `json:\"name\"`\n+}\n+\n+type EdgeDefinition struct {\n+\tID     string `json:\"id\"`\n+\tSource string `json:\"source\"`\n+\tTarget string `json:\"target\"`\n+}\n+\n+// getContextMemoryURL returns the base URL for context-memory API\n+// Uses CONTEXT_MEMORY_URL env var if set, otherwise defaults to production URL from source code\n+func getContextMemoryURL() string {\n+\tif url := os.Getenv(\"CONTEXT_MEMORY_URL\"); url != \"\" {\n+\t\treturn url\n+\t}\n+\treturn ContextAPIURL\n+}\n+\n+// baseURL shared across tests to avoid redeclaration issues\n+var baseURL string\n+\n+func TestContextMemoryExecutionSummary_SuccessfulWorkflow(t *testing.T) {\n+\tbaseURL = getContextMemoryURL()\n+\tauthToken := getAuthTokenOrSkip(t, baseURL)\n+\tt.Logf(\"Testing against: %s\", baseURL)\n+\n+\tclient := resty.New()\n+\tclient.SetTimeout(30 * time.Second)\n+\n+\t// Build request from VM-like structure\n+\trequest := SummarizeRequest{\n+\t\tOwnerEOA:    \"0xc60e71bd0f2e6d8832Fea1a2d56091C48493C788\",\n+\t\tName:        \"Test Workflow\",\n+\t\tSmartWallet: \"0xeCb88a770e1b2Ba303D0dC3B1c6F239fAB014bAE\",\n+\t\tChainName:   \"Sepolia\",\n+\t\tSteps: []StepDigest{\n+\t\t\t{\n+\t\t\t\tName:    \"balance1\",\n+\t\t\t\tID:      \"step1\",\n+\t\t\t\tType:    \"balance\",\n+\t\t\t\tSuccess: true,\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tName:            \"approve_token1\",\n+\t\t\t\tID:              \"step2\",\n+\t\t\t\tType:            \"contractWrite\",\n+\t\t\t\tSuccess:         true,\n+\t\t\t\tContractAddress: \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\",\n+\t\t\t\tMethodName:      \"approve\",\n+\t\t\t\tStepDescription: \"Approved 1000 USDC to Uniswap V3 router\",\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tName:    \"get_quote\",\n+\t\t\t\tID:      \"step3\",\n+\t\t\t\tType:    \"contractRead\",\n+\t\t\t\tSuccess: true,\n+\t\t\t},\n+\t\t},\n+\t\tNodes: []NodeDefinition{\n+\t\t\t{ID: \"node1\", Name: \"balance1\"},\n+\t\t\t{ID: \"node2\", Name: \"approve_token1\"},\n+\t\t\t{ID: \"node3\", Name: \"get_quote\"},\n+\t\t\t{ID: \"node4\", Name: \"run_swap\"},\n+\t\t},\n+\t\tEdges: []EdgeDefinition{\n+\t\t\t{ID: \"edge1\", Source: \"node1\", Target: \"node2\"},\n+\t\t\t{ID: \"edge2\", Source: \"node2\", Target: \"node3\"},\n+\t\t\t{ID: \"edge3\", Source: \"node3\", Target: \"node4\"},\n+\t\t},\n+\t}\n+\n+\tvar response ExecutionSummaryResponse\n+\turl := baseURL + \"/api/execution-summary\"\n+\n+\t// Log request details for debugging\n+\tt.Logf(\"Making POST request to: %s\", url)\n+\tt.Logf(\"Request body (first 500 chars): %s\", truncateString(mustMarshalJSON(request), 500))\n+\n+\tresp, err := client.R().\n+\t\tSetHeader(\"Authorization\", \"Bearer \"+authToken).\n+\t\tSetHeader(\"Content-Type\", \"application/json\").\n+\t\tSetBody(request).\n+\t\tSetResult(&response).\n+\t\tPost(url)\n+\n+\tif err != nil {\n+\t\tt.Fatalf(\"HTTP request failed: %v\", err)\n+\t}\n+\n+\tif resp.StatusCode() != 200 {\n+\t\tt.Logf(\"Response status: %d\", resp.StatusCode())\n+\t\tt.Logf(\"Response headers: %v\", resp.Header())\n+\t\tt.Logf(\"Full response body: %s\", string(resp.Body()))\n+\t\tt.Fatalf(\"Expected status 200, got %d. Response body: %s\", resp.StatusCode(), string(resp.Body()))\n+\t}\n+\n+\tt.Logf(\"Success! Response: status=%s, executedSteps=%d, totalSteps=%d\",\n+\t\tresponse.Status, response.ExecutedSteps, response.TotalSteps)\n+\n+\t// Validate response structure\n+\tif response.Status == \"\" {\n+\t\tt.Error(\"Response status should not be empty\")\n+\t}\n+\tif response.Status != \"success\" && response.Status != \"partial_success\" && response.Status != \"failure\" {\n+\t\tt.Errorf(\"Invalid status value: %s (expected 'success', 'partial_success', or 'failure')\", response.Status)\n+\t}\n+\n+\t// branchSummary should always be present (even if empty string)\n+\tif response.BranchSummary == \"\" {\n+\t\t// Empty string is valid when there are no skipped nodes\n+\t\tt.Log(\"branchSummary is empty (expected for successful workflow)\")\n+\t}\n+\n+\t// skippedNodes should always be present (even if empty array)\n+\tif response.SkippedNodes == nil {\n+\t\tt.Error(\"skippedNodes should not be nil\")\n+\t}\n+\n+\t// Validate metrics\n+\tif response.ExecutedSteps != 3 {\n+\t\tt.Errorf(\"Expected executedSteps=3, got %d\", response.ExecutedSteps)\n+\t}\n+\tif response.TotalSteps < response.ExecutedSteps {\n+\t\tt.Errorf(\"totalSteps (%d) should be >= executedSteps (%d)\", response.TotalSteps, response.ExecutedSteps)\n+\t}\n+\tif response.SkippedSteps < 0 {\n+\t\tt.Errorf(\"skippedSteps should be >= 0, got %d\", response.SkippedSteps)\n+\t}\n+\n+\t// For this test, we expect 1 skipped node (run_swap)\n+\tif response.SkippedSteps != 1 {\n+\t\tt.Errorf(\"Expected skippedSteps=1 (run_swap was skipped), got %d\", response.SkippedSteps)\n+\t}\n+\tif len(response.SkippedNodes) != 1 {\n+\t\tt.Errorf(\"Expected 1 skipped node, got %d: %v\", len(response.SkippedNodes), response.SkippedNodes)\n+\t}\n+\tif len(response.SkippedNodes) > 0 && response.SkippedNodes[0] != \"run_swap\" {\n+\t\tt.Errorf(\"Expected skipped node 'run_swap', got %s\", response.SkippedNodes[0])\n+\t}\n+\n+\tt.Logf(\"Response: status=%s, executedSteps=%d, totalSteps=%d, skippedSteps=%d, skippedNodes=%v\",\n+\t\tresponse.Status, response.ExecutedSteps, response.TotalSteps, response.SkippedSteps, response.SkippedNodes)\n+}\n+\n+func TestContextMemoryExecutionSummary_FailedWorkflow(t *testing.T) {\n+\tbaseURL = getContextMemoryURL()\n+\tauthToken := getAuthTokenOrSkip(t, baseURL)\n+\n+\tclient := resty.New()\n+\tclient.SetTimeout(30 * time.Second)\n+\n+\trequest := SummarizeRequest{\n+\t\tOwnerEOA:    \"0xc60e71bd0f2e6d8832Fea1a2d56091C48493C788\",\n+\t\tName:        \"Failed Workflow\",\n+\t\tSmartWallet: \"0xeCb88a770e1b2Ba303D0dC3B1c6F239fAB014bAE\",\n+\t\tChainName:   \"Sepolia\",\n+\t\tSteps: []StepDigest{\n+\t\t\t{\n+\t\t\t\tName:    \"approve_token\",\n+\t\t\t\tID:      \"step1\",\n+\t\t\t\tType:    \"contractWrite\",\n+\t\t\t\tSuccess: true,\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tName:    \"swap_tokens\",\n+\t\t\t\tID:      \"step2\",\n+\t\t\t\tType:    \"contractWrite\",\n+\t\t\t\tSuccess: false,\n+\t\t\t\tError:   \"Insufficient gas\",\n+\t\t\t},\n+\t\t},\n+\t\tNodes: []NodeDefinition{\n+\t\t\t{ID: \"node1\", Name: \"approve_token\"},\n+\t\t\t{ID: \"node2\", Name: \"swap_tokens\"},\n+\t\t},\n+\t}\n+\n+\tvar response ExecutionSummaryResponse\n+\turl := baseURL + \"/api/execution-summary\"\n+\n+\t// Log request details for debugging\n+\tt.Logf(\"Making POST request to: %s\", url)\n+\tt.Logf(\"Request body (first 500 chars): %s\", truncateString(mustMarshalJSON(request), 500))\n+\n+\tresp, err := client.R().\n+\t\tSetHeader(\"Authorization\", \"Bearer \"+authToken).\n+\t\tSetHeader(\"Content-Type\", \"application/json\").\n+\t\tSetBody(request).\n+\t\tSetResult(&response).\n+\t\tPost(url)\n+\n+\tif err != nil {\n+\t\tt.Fatalf(\"HTTP request failed: %v\", err)\n+\t}\n+\n+\tif resp.StatusCode() != 200 {\n+\t\tt.Logf(\"Response status: %d\", resp.StatusCode())\n+\t\tt.Logf(\"Response headers: %v\", resp.Header())\n+\t\tt.Logf(\"Full response body: %s\", string(resp.Body()))\n+\t\tt.Fatalf(\"Expected status 200, got %d. Response body: %s\", resp.StatusCode(), string(resp.Body()))\n+\t}\n+\n+\tt.Logf(\"Success! Response: status=%s, executedSteps=%d, totalSteps=%d\",\n+\t\tresponse.Status, response.ExecutedSteps, response.TotalSteps)\n+\n+\t// Validate failure status\n+\tif response.Status != \"failure\" {\n+\t\tt.Errorf(\"Expected status='failure', got %s\", response.Status)\n+\t}\n+\n+\t// Validate metrics\n+\tif response.ExecutedSteps != 2 {\n+\t\tt.Errorf(\"Expected executedSteps=2, got %d\", response.ExecutedSteps)\n+\t}\n+\n+\tt.Logf(\"Failed workflow response: status=%s, executedSteps=%d\", response.Status, response.ExecutedSteps)\n+}\n+\n+func TestContextMemoryExecutionSummary_CompleteWorkflow(t *testing.T) {\n+\tbaseURL = getContextMemoryURL()\n+\tauthToken := getAuthTokenOrSkip(t, baseURL)\n+\n+\tclient := resty.New()\n+\tclient.SetTimeout(30 * time.Second)\n+\n+\trequest := SummarizeRequest{\n+\t\tOwnerEOA:    \"0xc60e71bd0f2e6d8832Fea1a2d56091C48493C788\",\n+\t\tName:        \"Complete Workflow\",\n+\t\tSmartWallet: \"0xeCb88a770e1b2Ba303D0dC3B1c6F239fAB014bAE\",\n+\t\tChainName:   \"Sepolia\",\n+\t\tSteps: []StepDigest{\n+\t\t\t{\n+\t\t\t\tName:    \"balance1\",\n+\t\t\t\tID:      \"step1\",\n+\t\t\t\tType:    \"balance\",\n+\t\t\t\tSuccess: true,\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tName:    \"approve_token1\",\n+\t\t\t\tID:      \"step2\",\n+\t\t\t\tType:    \"contractWrite\",\n+\t\t\t\tSuccess: true,\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tName:    \"get_quote\",\n+\t\t\t\tID:      \"step3\",\n+\t\t\t\tType:    \"contractRead\",\n+\t\t\t\tSuccess: true,\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tName:    \"run_swap\",\n+\t\t\t\tID:      \"step4\",\n+\t\t\t\tType:    \"contractWrite\",\n+\t\t\t\tSuccess: true,\n+\t\t\t},\n+\t\t},\n+\t\tNodes: []NodeDefinition{\n+\t\t\t{ID: \"node1\", Name: \"balance1\"},\n+\t\t\t{ID: \"node2\", Name: \"approve_token1\"},\n+\t\t\t{ID: \"node3\", Name: \"get_quote\"},\n+\t\t\t{ID: \"node4\", Name: \"run_swap\"},\n+\t\t},\n+\t}\n+\n+\tvar response ExecutionSummaryResponse\n+\turl := baseURL + \"/api/execution-summary\"\n+\n+\t// Log request details for debugging\n+\tt.Logf(\"Making POST request to: %s\", url)\n+\tt.Logf(\"Request body (first 500 chars): %s\", truncateString(mustMarshalJSON(request), 500))\n+\n+\tresp, err := client.R().\n+\t\tSetHeader(\"Authorization\", \"Bearer \"+authToken).\n+\t\tSetHeader(\"Content-Type\", \"application/json\").\n+\t\tSetBody(request).\n+\t\tSetResult(&response).\n+\t\tPost(url)\n+\n+\tif err != nil {\n+\t\tt.Fatalf(\"HTTP request failed: %v\", err)\n+\t}\n+\n+\tif resp.StatusCode() != 200 {\n+\t\tt.Logf(\"Response status: %d\", resp.StatusCode())\n+\t\tt.Logf(\"Response headers: %v\", resp.Header())\n+\t\tt.Logf(\"Full response body: %s\", string(resp.Body()))\n+\t\tt.Fatalf(\"Expected status 200, got %d. Response body: %s\", resp.StatusCode(), string(resp.Body()))\n+\t}\n+\n+\tt.Logf(\"Success! Response: status=%s, executedSteps=%d, totalSteps=%d\",\n+\t\tresponse.Status, response.ExecutedSteps, response.TotalSteps)\n+\n+\t// Validate success status\n+\tif response.Status != \"success\" {\n+\t\tt.Errorf(\"Expected status='success', got %s\", response.Status)\n+\t}\n+\n+\t// All nodes executed, no skipped nodes\n+\tif response.SkippedSteps != 0 {\n+\t\tt.Errorf(\"Expected skippedSteps=0, got %d\", response.SkippedSteps)\n+\t}\n+\tif len(response.SkippedNodes) != 0 {\n+\t\tt.Errorf(\"Expected no skipped nodes, got %v\", response.SkippedNodes)\n+\t}\n+\tif response.ExecutedSteps != 4 {\n+\t\tt.Errorf(\"Expected executedSteps=4, got %d\", response.ExecutedSteps)\n+\t}\n+\tif response.TotalSteps != 4 {\n+\t\tt.Errorf(\"Expected totalSteps=4, got %d\", response.TotalSteps)\n+\t}\n+\n+\tt.Logf(\"Complete workflow response: status=%s, executedSteps=%d, totalSteps=%d\",\n+\t\tresponse.Status, response.ExecutedSteps, response.TotalSteps)\n+}\n+\n+func TestContextMemoryExecutionSummary_FromVM(t *testing.T) {\n+\tbaseURL = getContextMemoryURL()\n+\tauthToken := getAuthTokenOrSkip(t, baseURL)\n+\t// Create a VM similar to TestComposeSummarySmart_WithRealWorkflowState\n+\tvm := NewVM()\n+\tvm.TaskID = \"01K6H8R583M8WFXM2Z4APP7JTN\"\n+\n+\tvm.ExecutionLogs = []*avsproto.Execution_Step{\n+\t\t{Id: \"trigger\", Name: \"eventTrigger\", Type: \"eventTrigger\", Success: true},\n+\t\t{Id: \"step1\", Name: \"balance1\", Type: \"balance\", Success: true},\n+\t\t{Id: \"step2\", Name: \"branch1\", Type: \"branch\", Success: true},\n+\t\t{Id: \"step3\", Name: \"email_report\", Type: \"restApi\", Success: true},\n+\t}\n+\n+\tvm.mu.Lock()\n+\tvm.TaskNodes = map[string]*avsproto.TaskNode{\n+\t\t\"node1\": {Id: \"node1\", Name: \"balance1\"},\n+\t\t\"node2\": {Id: \"node2\", Name: \"branch1\"},\n+\t\t\"node3\": {Id: \"node3\", Name: \"approve_token1\"},\n+\t\t\"node4\": {Id: \"node4\", Name: \"get_quote\"},\n+\t\t\"node5\": {Id: \"node5\", Name: \"run_swap\"},\n+\t\t\"node6\": {Id: \"node6\", Name: \"email_report\"},\n+\t}\n+\tvm.vars = map[string]interface{}{\n+\t\t\"settings\": map[string]interface{}{\n+\t\t\t\"name\":   \"Test template\",\n+\t\t\t\"chain\":  \"Sepolia\",\n+\t\t\t\"runner\": \"0xeCb88a770e1b2Ba303D0dC3B1c6F239fAB014bAE\",\n+\t\t},\n+\t\tWorkflowContextVarName: map[string]interface{}{\n+\t\t\t\"name\":   \"Test template\",\n+\t\t\t\"runner\": \"0xeCb88a770e1b2Ba303D0dC3B1c6F239fAB014bAE\",\n+\t\t\t\"owner\":  \"0xc60e71bd0f2e6d8832Fea1a2d56091C48493C788\",\n+\t\t},\n+\t}\n+\tvm.mu.Unlock()\n+\n+\t// Convert VM to API request\n+\t// Note: buildSummarizeRequestFromVM locks vm.mu, so we call it before creating the client\n+\trequest := buildSummarizeRequestFromVM(vm)\n+\n+\tbaseURL = getContextMemoryURL()\n+\tt.Logf(\"Testing against: %s\", baseURL)\n+\n+\tclient := resty.New()\n+\tclient.SetTimeout(30 * time.Second)\n+\n+\tvar response ExecutionSummaryResponse\n+\turl := baseURL + \"/api/execution-summary\"\n+\n+\t// Log request details for debugging\n+\tt.Logf(\"Making POST request to: %s\", url)\n+\tt.Logf(\"Request body (first 500 chars): %s\", truncateString(mustMarshalJSON(request), 500))\n+\n+\tresp, err := client.R().\n+\t\tSetHeader(\"Authorization\", \"Bearer \"+authToken).\n+\t\tSetHeader(\"Content-Type\", \"application/json\").\n+\t\tSetBody(request).\n+\t\tSetResult(&response).\n+\t\tPost(url)\n+\n+\tif err != nil {\n+\t\tt.Fatalf(\"HTTP request failed: %v\", err)\n+\t}\n+\n+\tif resp.StatusCode() != 200 {\n+\t\tt.Logf(\"Response status: %d\", resp.StatusCode())\n+\t\tt.Logf(\"Response headers: %v\", resp.Header())\n+\t\tt.Logf(\"Full response body: %s\", string(resp.Body()))\n+\t\tt.Fatalf(\"Expected status 200, got %d. Response body: %s\", resp.StatusCode(), string(resp.Body()))\n+\t}\n+\n+\tt.Logf(\"Success! Response: status=%s, executedSteps=%d, totalSteps=%d\",\n+\t\tresponse.Status, response.ExecutedSteps, response.TotalSteps)\n+\n+\t// Validate response\n+\tif response.Status == \"\" {\n+\t\tt.Error(\"Response status should not be empty\")\n+\t}\n+\n+\t// Should have 4 executed steps (trigger + 3 nodes)\n+\tif response.ExecutedSteps != 4 {\n+\t\tt.Errorf(\"Expected executedSteps=4, got %d\", response.ExecutedSteps)\n+\t}\n+\n+\t// Should have 3 skipped nodes (approve_token1, get_quote, run_swap)\n+\tif response.SkippedSteps != 3 {\n+\t\tt.Errorf(\"Expected skippedSteps=3, got %d\", response.SkippedSteps)\n+\t}\n+\tif response.TotalSteps != 7 {\n+\t\tt.Errorf(\"Expected totalSteps=7 (4 executed + 3 skipped), got %d\", response.TotalSteps)\n+\t}\n+\n+\t// Validate skipped nodes\n+\texpectedSkipped := []string{\"approve_token1\", \"get_quote\", \"run_swap\"}\n+\tif len(response.SkippedNodes) != len(expectedSkipped) {\n+\t\tt.Errorf(\"Expected %d skipped nodes, got %d: %v\", len(expectedSkipped), len(response.SkippedNodes), response.SkippedNodes)\n+\t}\n+\n+\t// branchSummary should contain text about skipped nodes\n+\tif response.BranchSummary == \"\" {\n+\t\tt.Error(\"branchSummary should not be empty when there are skipped nodes\")\n+\t}\n+\tif !strings.Contains(response.BranchSummary, \"skipped\") {\n+\t\tt.Errorf(\"branchSummary should mention skipped nodes, got: %s\", response.BranchSummary)\n+\t}\n+\n+\tt.Logf(\"VM-based test response: status=%s, executedSteps=%d, totalSteps=%d, skippedSteps=%d, skippedNodes=%v\",\n+\t\tresponse.Status, response.ExecutedSteps, response.TotalSteps, response.SkippedSteps, response.SkippedNodes)\n+\tt.Logf(\"branchSummary: %s\", response.BranchSummary)\n+}\n+\n+// buildSummarizeRequestFromVM converts a VM to a SummarizeRequest\n+// This mimics what the aggregator will do when integrating with context-memory\n+func buildSummarizeRequestFromVM(vm *VM) SummarizeRequest {\n+\tvm.mu.Lock()\n+\tdefer vm.mu.Unlock()\n+\n+\t// Extract workflow context\n+\tvar ownerEOA, smartWallet, workflowName, chainName string\n+\tif wfCtx, ok := vm.vars[WorkflowContextVarName].(map[string]interface{}); ok {\n+\t\tif owner, ok := wfCtx[\"owner\"].(string); ok {\n+\t\t\townerEOA = owner\n+\t\t}\n+\t\tif runner, ok := wfCtx[\"runner\"].(string); ok {\n+\t\t\tsmartWallet = runner\n+\t\t}\n+\t\tif name, ok := wfCtx[\"name\"].(string); ok {\n+\t\t\tworkflowName = name\n+\t\t}\n+\t}\n+\tif settings, ok := vm.vars[\"settings\"].(map[string]interface{}); ok {\n+\t\tif name, ok := settings[\"name\"].(string); ok && workflowName == \"\" {\n+\t\t\tworkflowName = name\n+\t\t}\n+\t\tif chain, ok := settings[\"chain\"].(string); ok {\n+\t\t\tchainName = chain\n+\t\t}\n+\t\tif runner, ok := settings[\"runner\"].(string); ok && smartWallet == \"\" {\n+\t\t\tsmartWallet = runner\n+\t\t}\n+\t}\n+\n+\t// Convert execution logs to steps\n+\tsteps := make([]StepDigest, 0, len(vm.ExecutionLogs))\n+\tfor _, log := range vm.ExecutionLogs {\n+\t\tstep := StepDigest{\n+\t\t\tName:    log.GetName(),\n+\t\t\tID:      log.GetId(),\n+\t\t\tType:    log.GetType(),\n+\t\t\tSuccess: log.GetSuccess(),\n+\t\t}\n+\t\tif log.GetError() != \"\" {\n+\t\t\tstep.Error = log.GetError()\n+\t\t}\n+\t\tsteps = append(steps, step)\n+\t}\n+\n+\t// Convert TaskNodes to nodes\n+\tnodes := make([]NodeDefinition, 0, len(vm.TaskNodes))\n+\tfor nodeID, node := range vm.TaskNodes {\n+\t\tif node == nil {\n+\t\t\tcontinue\n+\t\t}\n+\t\t// Skip branch condition pseudo-nodes\n+\t\tif strings.Contains(nodeID, \".\") {",
        "body": "The branch node check logic is inconsistent between the test and production code. In the integration test, branch pseudo-nodes are identified using `strings.Contains(nodeID, \".\")` (line 537), while the production code in `summarizer_context_memory.go` uses `len(nodeID) > 0 && nodeID[0] == '.'` (line 234). These checks identify different patterns - the test skips any node with a dot anywhere in the ID, while production only skips nodes starting with a dot. This inconsistency could cause test results to differ from production behavior. Use the same logic in both places.\n```suggestion\n\t\t// Skip branch condition pseudo-nodes (IDs starting with '.')\n\t\tif len(nodeID) > 0 && nodeID[0] == '.' {\n```",
        "created_at": "2026-01-09T22:02:05Z",
        "user": "copilot-pull-request-reviewer"
      },
      {
        "id": "PRRC_kwDOLqYZns6fmxfk",
        "path": "core/taskengine/summarizer_context_memory_integration_test.go",
        "line": 586,
        "diff_hunk": "@@ -0,0 +1,602 @@\n+//go:build integration\n+// +build integration\n+\n+package taskengine\n+\n+import (\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"strings\"\n+\t\"testing\"\n+\t\"time\"\n+\n+\tavsproto \"github.com/AvaProtocol/EigenLayer-AVS/protobuf\"\n+\t\"github.com/go-resty/resty/v2\"\n+)\n+\n+// ExecutionSummaryResponse matches the TypeScript ExecutionSummaryResponse interface\n+type ExecutionSummaryResponse struct {\n+\tStatus        string   `json:\"status\"`        // 'success' | 'partial_success' | 'failure'\n+\tBranchSummary string   `json:\"branchSummary\"` // Plain text summary\n+\tSkippedNodes  []string `json:\"skippedNodes\"`  // Array of skipped node names\n+\tTotalSteps    int      `json:\"totalSteps\"`    // Total steps in workflow\n+\tExecutedSteps int      `json:\"executedSteps\"` // Number of steps executed\n+\tSkippedSteps  int      `json:\"skippedSteps\"`  // Number of skipped steps\n+}\n+\n+// SummarizeRequest matches the TypeScript SummarizeRequest interface\n+type SummarizeRequest struct {\n+\tOwnerEOA        string                 `json:\"ownerEOA\"`\n+\tName            string                 `json:\"name\"`\n+\tSmartWallet     string                 `json:\"smartWallet\"`\n+\tSteps           []StepDigest           `json:\"steps\"`\n+\tChainName       string                 `json:\"chainName,omitempty\"`\n+\tNodes           []NodeDefinition       `json:\"nodes,omitempty\"`\n+\tEdges           []EdgeDefinition       `json:\"edges,omitempty\"`\n+\tSettings        map[string]interface{} `json:\"settings,omitempty\"`\n+\tCurrentNodeName string                 `json:\"currentNodeName,omitempty\"`\n+}\n+\n+type StepDigest struct {\n+\tName            string                 `json:\"name\"`\n+\tID              string                 `json:\"id\"`\n+\tType            string                 `json:\"type\"`\n+\tSuccess         bool                   `json:\"success\"`\n+\tError           string                 `json:\"error,omitempty\"`\n+\tContractAddress string                 `json:\"contractAddress,omitempty\"`\n+\tMethodName      string                 `json:\"methodName,omitempty\"`\n+\tMethodParams    map[string]interface{} `json:\"methodParams,omitempty\"`\n+\tOutputData      interface{}            `json:\"outputData,omitempty\"`\n+\tMetadata        interface{}            `json:\"metadata,omitempty\"`\n+\tStepDescription string                 `json:\"stepDescription,omitempty\"`\n+}\n+\n+type NodeDefinition struct {\n+\tID   string `json:\"id\"`\n+\tName string `json:\"name\"`\n+}\n+\n+type EdgeDefinition struct {\n+\tID     string `json:\"id\"`\n+\tSource string `json:\"source\"`\n+\tTarget string `json:\"target\"`\n+}\n+\n+// getContextMemoryURL returns the base URL for context-memory API\n+// Uses CONTEXT_MEMORY_URL env var if set, otherwise defaults to production URL from source code\n+func getContextMemoryURL() string {\n+\tif url := os.Getenv(\"CONTEXT_MEMORY_URL\"); url != \"\" {\n+\t\treturn url\n+\t}\n+\treturn ContextAPIURL\n+}\n+\n+// baseURL shared across tests to avoid redeclaration issues\n+var baseURL string\n+\n+func TestContextMemoryExecutionSummary_SuccessfulWorkflow(t *testing.T) {\n+\tbaseURL = getContextMemoryURL()\n+\tauthToken := getAuthTokenOrSkip(t, baseURL)\n+\tt.Logf(\"Testing against: %s\", baseURL)\n+\n+\tclient := resty.New()\n+\tclient.SetTimeout(30 * time.Second)\n+\n+\t// Build request from VM-like structure\n+\trequest := SummarizeRequest{\n+\t\tOwnerEOA:    \"0xc60e71bd0f2e6d8832Fea1a2d56091C48493C788\",\n+\t\tName:        \"Test Workflow\",\n+\t\tSmartWallet: \"0xeCb88a770e1b2Ba303D0dC3B1c6F239fAB014bAE\",\n+\t\tChainName:   \"Sepolia\",\n+\t\tSteps: []StepDigest{\n+\t\t\t{\n+\t\t\t\tName:    \"balance1\",\n+\t\t\t\tID:      \"step1\",\n+\t\t\t\tType:    \"balance\",\n+\t\t\t\tSuccess: true,\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tName:            \"approve_token1\",\n+\t\t\t\tID:              \"step2\",\n+\t\t\t\tType:            \"contractWrite\",\n+\t\t\t\tSuccess:         true,\n+\t\t\t\tContractAddress: \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\",\n+\t\t\t\tMethodName:      \"approve\",\n+\t\t\t\tStepDescription: \"Approved 1000 USDC to Uniswap V3 router\",\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tName:    \"get_quote\",\n+\t\t\t\tID:      \"step3\",\n+\t\t\t\tType:    \"contractRead\",\n+\t\t\t\tSuccess: true,\n+\t\t\t},\n+\t\t},\n+\t\tNodes: []NodeDefinition{\n+\t\t\t{ID: \"node1\", Name: \"balance1\"},\n+\t\t\t{ID: \"node2\", Name: \"approve_token1\"},\n+\t\t\t{ID: \"node3\", Name: \"get_quote\"},\n+\t\t\t{ID: \"node4\", Name: \"run_swap\"},\n+\t\t},\n+\t\tEdges: []EdgeDefinition{\n+\t\t\t{ID: \"edge1\", Source: \"node1\", Target: \"node2\"},\n+\t\t\t{ID: \"edge2\", Source: \"node2\", Target: \"node3\"},\n+\t\t\t{ID: \"edge3\", Source: \"node3\", Target: \"node4\"},\n+\t\t},\n+\t}\n+\n+\tvar response ExecutionSummaryResponse\n+\turl := baseURL + \"/api/execution-summary\"\n+\n+\t// Log request details for debugging\n+\tt.Logf(\"Making POST request to: %s\", url)\n+\tt.Logf(\"Request body (first 500 chars): %s\", truncateString(mustMarshalJSON(request), 500))\n+\n+\tresp, err := client.R().\n+\t\tSetHeader(\"Authorization\", \"Bearer \"+authToken).\n+\t\tSetHeader(\"Content-Type\", \"application/json\").\n+\t\tSetBody(request).\n+\t\tSetResult(&response).\n+\t\tPost(url)\n+\n+\tif err != nil {\n+\t\tt.Fatalf(\"HTTP request failed: %v\", err)\n+\t}\n+\n+\tif resp.StatusCode() != 200 {\n+\t\tt.Logf(\"Response status: %d\", resp.StatusCode())\n+\t\tt.Logf(\"Response headers: %v\", resp.Header())\n+\t\tt.Logf(\"Full response body: %s\", string(resp.Body()))\n+\t\tt.Fatalf(\"Expected status 200, got %d. Response body: %s\", resp.StatusCode(), string(resp.Body()))\n+\t}\n+\n+\tt.Logf(\"Success! Response: status=%s, executedSteps=%d, totalSteps=%d\",\n+\t\tresponse.Status, response.ExecutedSteps, response.TotalSteps)\n+\n+\t// Validate response structure\n+\tif response.Status == \"\" {\n+\t\tt.Error(\"Response status should not be empty\")\n+\t}\n+\tif response.Status != \"success\" && response.Status != \"partial_success\" && response.Status != \"failure\" {\n+\t\tt.Errorf(\"Invalid status value: %s (expected 'success', 'partial_success', or 'failure')\", response.Status)\n+\t}\n+\n+\t// branchSummary should always be present (even if empty string)\n+\tif response.BranchSummary == \"\" {\n+\t\t// Empty string is valid when there are no skipped nodes\n+\t\tt.Log(\"branchSummary is empty (expected for successful workflow)\")\n+\t}\n+\n+\t// skippedNodes should always be present (even if empty array)\n+\tif response.SkippedNodes == nil {\n+\t\tt.Error(\"skippedNodes should not be nil\")\n+\t}\n+\n+\t// Validate metrics\n+\tif response.ExecutedSteps != 3 {\n+\t\tt.Errorf(\"Expected executedSteps=3, got %d\", response.ExecutedSteps)\n+\t}\n+\tif response.TotalSteps < response.ExecutedSteps {\n+\t\tt.Errorf(\"totalSteps (%d) should be >= executedSteps (%d)\", response.TotalSteps, response.ExecutedSteps)\n+\t}\n+\tif response.SkippedSteps < 0 {\n+\t\tt.Errorf(\"skippedSteps should be >= 0, got %d\", response.SkippedSteps)\n+\t}\n+\n+\t// For this test, we expect 1 skipped node (run_swap)\n+\tif response.SkippedSteps != 1 {\n+\t\tt.Errorf(\"Expected skippedSteps=1 (run_swap was skipped), got %d\", response.SkippedSteps)\n+\t}\n+\tif len(response.SkippedNodes) != 1 {\n+\t\tt.Errorf(\"Expected 1 skipped node, got %d: %v\", len(response.SkippedNodes), response.SkippedNodes)\n+\t}\n+\tif len(response.SkippedNodes) > 0 && response.SkippedNodes[0] != \"run_swap\" {\n+\t\tt.Errorf(\"Expected skipped node 'run_swap', got %s\", response.SkippedNodes[0])\n+\t}\n+\n+\tt.Logf(\"Response: status=%s, executedSteps=%d, totalSteps=%d, skippedSteps=%d, skippedNodes=%v\",\n+\t\tresponse.Status, response.ExecutedSteps, response.TotalSteps, response.SkippedSteps, response.SkippedNodes)\n+}\n+\n+func TestContextMemoryExecutionSummary_FailedWorkflow(t *testing.T) {\n+\tbaseURL = getContextMemoryURL()\n+\tauthToken := getAuthTokenOrSkip(t, baseURL)\n+\n+\tclient := resty.New()\n+\tclient.SetTimeout(30 * time.Second)\n+\n+\trequest := SummarizeRequest{\n+\t\tOwnerEOA:    \"0xc60e71bd0f2e6d8832Fea1a2d56091C48493C788\",\n+\t\tName:        \"Failed Workflow\",\n+\t\tSmartWallet: \"0xeCb88a770e1b2Ba303D0dC3B1c6F239fAB014bAE\",\n+\t\tChainName:   \"Sepolia\",\n+\t\tSteps: []StepDigest{\n+\t\t\t{\n+\t\t\t\tName:    \"approve_token\",\n+\t\t\t\tID:      \"step1\",\n+\t\t\t\tType:    \"contractWrite\",\n+\t\t\t\tSuccess: true,\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tName:    \"swap_tokens\",\n+\t\t\t\tID:      \"step2\",\n+\t\t\t\tType:    \"contractWrite\",\n+\t\t\t\tSuccess: false,\n+\t\t\t\tError:   \"Insufficient gas\",\n+\t\t\t},\n+\t\t},\n+\t\tNodes: []NodeDefinition{\n+\t\t\t{ID: \"node1\", Name: \"approve_token\"},\n+\t\t\t{ID: \"node2\", Name: \"swap_tokens\"},\n+\t\t},\n+\t}\n+\n+\tvar response ExecutionSummaryResponse\n+\turl := baseURL + \"/api/execution-summary\"\n+\n+\t// Log request details for debugging\n+\tt.Logf(\"Making POST request to: %s\", url)\n+\tt.Logf(\"Request body (first 500 chars): %s\", truncateString(mustMarshalJSON(request), 500))\n+\n+\tresp, err := client.R().\n+\t\tSetHeader(\"Authorization\", \"Bearer \"+authToken).\n+\t\tSetHeader(\"Content-Type\", \"application/json\").\n+\t\tSetBody(request).\n+\t\tSetResult(&response).\n+\t\tPost(url)\n+\n+\tif err != nil {\n+\t\tt.Fatalf(\"HTTP request failed: %v\", err)\n+\t}\n+\n+\tif resp.StatusCode() != 200 {\n+\t\tt.Logf(\"Response status: %d\", resp.StatusCode())\n+\t\tt.Logf(\"Response headers: %v\", resp.Header())\n+\t\tt.Logf(\"Full response body: %s\", string(resp.Body()))\n+\t\tt.Fatalf(\"Expected status 200, got %d. Response body: %s\", resp.StatusCode(), string(resp.Body()))\n+\t}\n+\n+\tt.Logf(\"Success! Response: status=%s, executedSteps=%d, totalSteps=%d\",\n+\t\tresponse.Status, response.ExecutedSteps, response.TotalSteps)\n+\n+\t// Validate failure status\n+\tif response.Status != \"failure\" {\n+\t\tt.Errorf(\"Expected status='failure', got %s\", response.Status)\n+\t}\n+\n+\t// Validate metrics\n+\tif response.ExecutedSteps != 2 {\n+\t\tt.Errorf(\"Expected executedSteps=2, got %d\", response.ExecutedSteps)\n+\t}\n+\n+\tt.Logf(\"Failed workflow response: status=%s, executedSteps=%d\", response.Status, response.ExecutedSteps)\n+}\n+\n+func TestContextMemoryExecutionSummary_CompleteWorkflow(t *testing.T) {\n+\tbaseURL = getContextMemoryURL()\n+\tauthToken := getAuthTokenOrSkip(t, baseURL)\n+\n+\tclient := resty.New()\n+\tclient.SetTimeout(30 * time.Second)\n+\n+\trequest := SummarizeRequest{\n+\t\tOwnerEOA:    \"0xc60e71bd0f2e6d8832Fea1a2d56091C48493C788\",\n+\t\tName:        \"Complete Workflow\",\n+\t\tSmartWallet: \"0xeCb88a770e1b2Ba303D0dC3B1c6F239fAB014bAE\",\n+\t\tChainName:   \"Sepolia\",\n+\t\tSteps: []StepDigest{\n+\t\t\t{\n+\t\t\t\tName:    \"balance1\",\n+\t\t\t\tID:      \"step1\",\n+\t\t\t\tType:    \"balance\",\n+\t\t\t\tSuccess: true,\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tName:    \"approve_token1\",\n+\t\t\t\tID:      \"step2\",\n+\t\t\t\tType:    \"contractWrite\",\n+\t\t\t\tSuccess: true,\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tName:    \"get_quote\",\n+\t\t\t\tID:      \"step3\",\n+\t\t\t\tType:    \"contractRead\",\n+\t\t\t\tSuccess: true,\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tName:    \"run_swap\",\n+\t\t\t\tID:      \"step4\",\n+\t\t\t\tType:    \"contractWrite\",\n+\t\t\t\tSuccess: true,\n+\t\t\t},\n+\t\t},\n+\t\tNodes: []NodeDefinition{\n+\t\t\t{ID: \"node1\", Name: \"balance1\"},\n+\t\t\t{ID: \"node2\", Name: \"approve_token1\"},\n+\t\t\t{ID: \"node3\", Name: \"get_quote\"},\n+\t\t\t{ID: \"node4\", Name: \"run_swap\"},\n+\t\t},\n+\t}\n+\n+\tvar response ExecutionSummaryResponse\n+\turl := baseURL + \"/api/execution-summary\"\n+\n+\t// Log request details for debugging\n+\tt.Logf(\"Making POST request to: %s\", url)\n+\tt.Logf(\"Request body (first 500 chars): %s\", truncateString(mustMarshalJSON(request), 500))\n+\n+\tresp, err := client.R().\n+\t\tSetHeader(\"Authorization\", \"Bearer \"+authToken).\n+\t\tSetHeader(\"Content-Type\", \"application/json\").\n+\t\tSetBody(request).\n+\t\tSetResult(&response).\n+\t\tPost(url)\n+\n+\tif err != nil {\n+\t\tt.Fatalf(\"HTTP request failed: %v\", err)\n+\t}\n+\n+\tif resp.StatusCode() != 200 {\n+\t\tt.Logf(\"Response status: %d\", resp.StatusCode())\n+\t\tt.Logf(\"Response headers: %v\", resp.Header())\n+\t\tt.Logf(\"Full response body: %s\", string(resp.Body()))\n+\t\tt.Fatalf(\"Expected status 200, got %d. Response body: %s\", resp.StatusCode(), string(resp.Body()))\n+\t}\n+\n+\tt.Logf(\"Success! Response: status=%s, executedSteps=%d, totalSteps=%d\",\n+\t\tresponse.Status, response.ExecutedSteps, response.TotalSteps)\n+\n+\t// Validate success status\n+\tif response.Status != \"success\" {\n+\t\tt.Errorf(\"Expected status='success', got %s\", response.Status)\n+\t}\n+\n+\t// All nodes executed, no skipped nodes\n+\tif response.SkippedSteps != 0 {\n+\t\tt.Errorf(\"Expected skippedSteps=0, got %d\", response.SkippedSteps)\n+\t}\n+\tif len(response.SkippedNodes) != 0 {\n+\t\tt.Errorf(\"Expected no skipped nodes, got %v\", response.SkippedNodes)\n+\t}\n+\tif response.ExecutedSteps != 4 {\n+\t\tt.Errorf(\"Expected executedSteps=4, got %d\", response.ExecutedSteps)\n+\t}\n+\tif response.TotalSteps != 4 {\n+\t\tt.Errorf(\"Expected totalSteps=4, got %d\", response.TotalSteps)\n+\t}\n+\n+\tt.Logf(\"Complete workflow response: status=%s, executedSteps=%d, totalSteps=%d\",\n+\t\tresponse.Status, response.ExecutedSteps, response.TotalSteps)\n+}\n+\n+func TestContextMemoryExecutionSummary_FromVM(t *testing.T) {\n+\tbaseURL = getContextMemoryURL()\n+\tauthToken := getAuthTokenOrSkip(t, baseURL)\n+\t// Create a VM similar to TestComposeSummarySmart_WithRealWorkflowState\n+\tvm := NewVM()\n+\tvm.TaskID = \"01K6H8R583M8WFXM2Z4APP7JTN\"\n+\n+\tvm.ExecutionLogs = []*avsproto.Execution_Step{\n+\t\t{Id: \"trigger\", Name: \"eventTrigger\", Type: \"eventTrigger\", Success: true},\n+\t\t{Id: \"step1\", Name: \"balance1\", Type: \"balance\", Success: true},\n+\t\t{Id: \"step2\", Name: \"branch1\", Type: \"branch\", Success: true},\n+\t\t{Id: \"step3\", Name: \"email_report\", Type: \"restApi\", Success: true},\n+\t}\n+\n+\tvm.mu.Lock()\n+\tvm.TaskNodes = map[string]*avsproto.TaskNode{\n+\t\t\"node1\": {Id: \"node1\", Name: \"balance1\"},\n+\t\t\"node2\": {Id: \"node2\", Name: \"branch1\"},\n+\t\t\"node3\": {Id: \"node3\", Name: \"approve_token1\"},\n+\t\t\"node4\": {Id: \"node4\", Name: \"get_quote\"},\n+\t\t\"node5\": {Id: \"node5\", Name: \"run_swap\"},\n+\t\t\"node6\": {Id: \"node6\", Name: \"email_report\"},\n+\t}\n+\tvm.vars = map[string]interface{}{\n+\t\t\"settings\": map[string]interface{}{\n+\t\t\t\"name\":   \"Test template\",\n+\t\t\t\"chain\":  \"Sepolia\",\n+\t\t\t\"runner\": \"0xeCb88a770e1b2Ba303D0dC3B1c6F239fAB014bAE\",\n+\t\t},\n+\t\tWorkflowContextVarName: map[string]interface{}{\n+\t\t\t\"name\":   \"Test template\",\n+\t\t\t\"runner\": \"0xeCb88a770e1b2Ba303D0dC3B1c6F239fAB014bAE\",\n+\t\t\t\"owner\":  \"0xc60e71bd0f2e6d8832Fea1a2d56091C48493C788\",\n+\t\t},\n+\t}\n+\tvm.mu.Unlock()\n+\n+\t// Convert VM to API request\n+\t// Note: buildSummarizeRequestFromVM locks vm.mu, so we call it before creating the client\n+\trequest := buildSummarizeRequestFromVM(vm)\n+\n+\tbaseURL = getContextMemoryURL()\n+\tt.Logf(\"Testing against: %s\", baseURL)\n+\n+\tclient := resty.New()\n+\tclient.SetTimeout(30 * time.Second)\n+\n+\tvar response ExecutionSummaryResponse\n+\turl := baseURL + \"/api/execution-summary\"\n+\n+\t// Log request details for debugging\n+\tt.Logf(\"Making POST request to: %s\", url)\n+\tt.Logf(\"Request body (first 500 chars): %s\", truncateString(mustMarshalJSON(request), 500))\n+\n+\tresp, err := client.R().\n+\t\tSetHeader(\"Authorization\", \"Bearer \"+authToken).\n+\t\tSetHeader(\"Content-Type\", \"application/json\").\n+\t\tSetBody(request).\n+\t\tSetResult(&response).\n+\t\tPost(url)\n+\n+\tif err != nil {\n+\t\tt.Fatalf(\"HTTP request failed: %v\", err)\n+\t}\n+\n+\tif resp.StatusCode() != 200 {\n+\t\tt.Logf(\"Response status: %d\", resp.StatusCode())\n+\t\tt.Logf(\"Response headers: %v\", resp.Header())\n+\t\tt.Logf(\"Full response body: %s\", string(resp.Body()))\n+\t\tt.Fatalf(\"Expected status 200, got %d. Response body: %s\", resp.StatusCode(), string(resp.Body()))\n+\t}\n+\n+\tt.Logf(\"Success! Response: status=%s, executedSteps=%d, totalSteps=%d\",\n+\t\tresponse.Status, response.ExecutedSteps, response.TotalSteps)\n+\n+\t// Validate response\n+\tif response.Status == \"\" {\n+\t\tt.Error(\"Response status should not be empty\")\n+\t}\n+\n+\t// Should have 4 executed steps (trigger + 3 nodes)\n+\tif response.ExecutedSteps != 4 {\n+\t\tt.Errorf(\"Expected executedSteps=4, got %d\", response.ExecutedSteps)\n+\t}\n+\n+\t// Should have 3 skipped nodes (approve_token1, get_quote, run_swap)\n+\tif response.SkippedSteps != 3 {\n+\t\tt.Errorf(\"Expected skippedSteps=3, got %d\", response.SkippedSteps)\n+\t}\n+\tif response.TotalSteps != 7 {\n+\t\tt.Errorf(\"Expected totalSteps=7 (4 executed + 3 skipped), got %d\", response.TotalSteps)\n+\t}\n+\n+\t// Validate skipped nodes\n+\texpectedSkipped := []string{\"approve_token1\", \"get_quote\", \"run_swap\"}\n+\tif len(response.SkippedNodes) != len(expectedSkipped) {\n+\t\tt.Errorf(\"Expected %d skipped nodes, got %d: %v\", len(expectedSkipped), len(response.SkippedNodes), response.SkippedNodes)\n+\t}\n+\n+\t// branchSummary should contain text about skipped nodes\n+\tif response.BranchSummary == \"\" {\n+\t\tt.Error(\"branchSummary should not be empty when there are skipped nodes\")\n+\t}\n+\tif !strings.Contains(response.BranchSummary, \"skipped\") {\n+\t\tt.Errorf(\"branchSummary should mention skipped nodes, got: %s\", response.BranchSummary)\n+\t}\n+\n+\tt.Logf(\"VM-based test response: status=%s, executedSteps=%d, totalSteps=%d, skippedSteps=%d, skippedNodes=%v\",\n+\t\tresponse.Status, response.ExecutedSteps, response.TotalSteps, response.SkippedSteps, response.SkippedNodes)\n+\tt.Logf(\"branchSummary: %s\", response.BranchSummary)\n+}\n+\n+// buildSummarizeRequestFromVM converts a VM to a SummarizeRequest\n+// This mimics what the aggregator will do when integrating with context-memory\n+func buildSummarizeRequestFromVM(vm *VM) SummarizeRequest {\n+\tvm.mu.Lock()\n+\tdefer vm.mu.Unlock()\n+\n+\t// Extract workflow context\n+\tvar ownerEOA, smartWallet, workflowName, chainName string\n+\tif wfCtx, ok := vm.vars[WorkflowContextVarName].(map[string]interface{}); ok {\n+\t\tif owner, ok := wfCtx[\"owner\"].(string); ok {\n+\t\t\townerEOA = owner\n+\t\t}\n+\t\tif runner, ok := wfCtx[\"runner\"].(string); ok {\n+\t\t\tsmartWallet = runner\n+\t\t}\n+\t\tif name, ok := wfCtx[\"name\"].(string); ok {\n+\t\t\tworkflowName = name\n+\t\t}\n+\t}\n+\tif settings, ok := vm.vars[\"settings\"].(map[string]interface{}); ok {\n+\t\tif name, ok := settings[\"name\"].(string); ok && workflowName == \"\" {\n+\t\t\tworkflowName = name\n+\t\t}\n+\t\tif chain, ok := settings[\"chain\"].(string); ok {\n+\t\t\tchainName = chain\n+\t\t}\n+\t\tif runner, ok := settings[\"runner\"].(string); ok && smartWallet == \"\" {\n+\t\t\tsmartWallet = runner\n+\t\t}\n+\t}\n+\n+\t// Convert execution logs to steps\n+\tsteps := make([]StepDigest, 0, len(vm.ExecutionLogs))\n+\tfor _, log := range vm.ExecutionLogs {\n+\t\tstep := StepDigest{\n+\t\t\tName:    log.GetName(),\n+\t\t\tID:      log.GetId(),\n+\t\t\tType:    log.GetType(),\n+\t\t\tSuccess: log.GetSuccess(),\n+\t\t}\n+\t\tif log.GetError() != \"\" {\n+\t\t\tstep.Error = log.GetError()\n+\t\t}\n+\t\tsteps = append(steps, step)\n+\t}\n+\n+\t// Convert TaskNodes to nodes\n+\tnodes := make([]NodeDefinition, 0, len(vm.TaskNodes))\n+\tfor nodeID, node := range vm.TaskNodes {\n+\t\tif node == nil {\n+\t\t\tcontinue\n+\t\t}\n+\t\t// Skip branch condition pseudo-nodes\n+\t\tif strings.Contains(nodeID, \".\") {\n+\t\t\tcontinue\n+\t\t}\n+\t\tnodes = append(nodes, NodeDefinition{\n+\t\t\tID:   nodeID,\n+\t\t\tName: node.GetName(),\n+\t\t})\n+\t}\n+\n+\t// Convert edges (if available)\n+\t// Note: vm.task is a *model.Task which contains the protobuf Task\n+\tedges := make([]EdgeDefinition, 0)\n+\tif vm.task != nil && vm.task.Task != nil && vm.task.Task.Edges != nil {\n+\t\tfor _, edge := range vm.task.Task.Edges {\n+\t\t\tedges = append(edges, EdgeDefinition{\n+\t\t\t\tID:     edge.GetId(),\n+\t\t\t\tSource: edge.GetSource(),\n+\t\t\t\tTarget: edge.GetTarget(),\n+\t\t\t})\n+\t\t}\n+\t}\n+\n+\treturn SummarizeRequest{\n+\t\tOwnerEOA:    ownerEOA,\n+\t\tName:        workflowName,\n+\t\tSmartWallet: smartWallet,\n+\t\tSteps:       steps,\n+\t\tChainName:   chainName,\n+\t\tNodes:       nodes,\n+\t\tEdges:       edges,\n+\t}\n+}\n+\n+// getAuthTokenOrSkip returns the auth token for context-api requests\n+// Accepts SERVICE_AUTH_TOKEN env var override, or uses default local token for localhost URLs\n+func getAuthTokenOrSkip(t *testing.T, baseURL string) string {\n+\tt.Helper()\n+\t// Check for SERVICE_AUTH_TOKEN override first (works for any URL)\n+\tif authToken := os.Getenv(\"SERVICE_AUTH_TOKEN\"); authToken != \"\" {\n+\t\treturn authToken\n+\t}\n+\t// For localhost URLs, use default local token if SERVICE_AUTH_TOKEN not set\n+\tif strings.Contains(baseURL, \"localhost\") {\n+\t\tt.Logf(\"SERVICE_AUTH_TOKEN not set, using default local token\")\n+\t\treturn ContextMemoryAuthToken\n+\t}\n+\t// For production URLs, require SERVICE_AUTH_TOKEN to be set\n+\tt.Skip(\"SERVICE_AUTH_TOKEN not set, skipping integration test\")\n+\treturn \"\"\n+}",
        "body": "Missing validation for auth token when using production URLs. The test skips when `SERVICE_AUTH_TOKEN` is not set for production URLs (line 584), but there's no validation that the token is non-empty or properly formatted. An empty string from the environment variable would pass the `authToken != \"\"` check on line 575. Consider adding validation: `if authToken := os.Getenv(\"SERVICE_AUTH_TOKEN\"); authToken != \"\" && strings.TrimSpace(authToken) != \"\" { return authToken }`",
        "created_at": "2026-01-09T22:02:05Z",
        "user": "copilot-pull-request-reviewer"
      },
      {
        "id": "PRRC_kwDOLqYZns6fmxfv",
        "path": "core/taskengine/summarizer_context_memory.go",
        "line": 222,
        "diff_hunk": "@@ -0,0 +1,280 @@\n+package taskengine\n+\n+import (\n+\t\"bytes\"\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"net/http\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"github.com/ethereum/go-ethereum/common\"\n+)\n+\n+const (\n+\t// ContextAPIURL is the production URL for the context-api service\n+\tContextAPIURL = \"https://context-api.avaprotocol.org\"\n+)\n+\n+// ContextMemorySummarizer implements Summarizer using the context-memory API\n+type ContextMemorySummarizer struct {\n+\tbaseURL    string\n+\tauthToken  string\n+\thttpClient *http.Client\n+}\n+\n+// NewContextMemorySummarizer creates a new summarizer that calls context-memory API\n+// baseURL defaults to ContextAPIURL (production) if empty\n+func NewContextMemorySummarizer(baseURL, authToken string) Summarizer {\n+\tif baseURL == \"\" {\n+\t\tbaseURL = ContextAPIURL\n+\t}\n+\treturn &ContextMemorySummarizer{\n+\t\tbaseURL:    baseURL,\n+\t\tauthToken:  authToken,\n+\t\thttpClient: &http.Client{Timeout: 10 * time.Second},\n+\t}\n+}\n+\n+// SummarizeRequest matches the TypeScript interface for /api/summarize\n+type contextMemorySummarizeRequest struct {\n+\tOwnerEOA        string                    `json:\"ownerEOA\"`\n+\tName            string                    `json:\"name\"`\n+\tSmartWallet     string                    `json:\"smartWallet\"`\n+\tSteps           []contextMemoryStepDigest `json:\"steps\"`\n+\tChainName       string                    `json:\"chainName,omitempty\"`\n+\tNodes           []contextMemoryNodeDef    `json:\"nodes,omitempty\"`\n+\tEdges           []contextMemoryEdgeDef    `json:\"edges,omitempty\"`\n+\tSettings        map[string]interface{}    `json:\"settings,omitempty\"`\n+\tCurrentNodeName string                    `json:\"currentNodeName,omitempty\"`\n+}\n+\n+type contextMemoryStepDigest struct {\n+\tName             string                 `json:\"name\"`\n+\tID               string                 `json:\"id\"`\n+\tType             string                 `json:\"type\"`\n+\tSuccess          bool                   `json:\"success\"`\n+\tError            string                 `json:\"error,omitempty\"`\n+\tContractAddress  string                 `json:\"contractAddress,omitempty\"`\n+\tMethodName       string                 `json:\"methodName,omitempty\"`\n+\tMethodParams     map[string]interface{} `json:\"methodParams,omitempty\"`\n+\tOutputData       interface{}            `json:\"outputData,omitempty\"`\n+\tMetadata         interface{}            `json:\"metadata,omitempty\"`\n+\tStepDescription  string                 `json:\"stepDescription,omitempty\"`\n+\tExecutionContext interface{}            `json:\"executionContext,omitempty\"` // Actual execution mode (is_simulated, provider, chain_id)\n+}\n+\n+type contextMemoryNodeDef struct {\n+\tID   string `json:\"id\"`\n+\tName string `json:\"name\"`\n+}\n+\n+type contextMemoryEdgeDef struct {\n+\tID     string `json:\"id\"`\n+\tSource string `json:\"source\"`\n+\tTarget string `json:\"target\"`\n+}\n+\n+// SummarizeResponse matches the TypeScript SummarizeResponse\n+type contextMemorySummarizeResponse struct {\n+\tSubject       string `json:\"subject\"`\n+\tSummary       string `json:\"summary\"`      // One-liner summary\n+\tAnalysisHtml  string `json:\"analysisHtml\"` // Pre-formatted HTML with  symbols\n+\tBody          string `json:\"body\"`         // Plain text body (for backward compatibility)\n+\tStatusHtml    string `json:\"statusHtml\"`   // Status badge HTML (green/yellow/red badge with icon)\n+\tStatus        string `json:\"status\"`       // Execution status: \"success\", \"partial_success\", \"failure\"\n+\tPromptVersion string `json:\"promptVersion\"`\n+\tCached        bool   `json:\"cached,omitempty\"`\n+}\n+\n+func (c *ContextMemorySummarizer) Summarize(ctx context.Context, vm *VM, currentStepName string) (Summary, error) {\n+\tif c == nil || c.httpClient == nil {\n+\t\treturn Summary{}, fmt.Errorf(\"summarizer not initialized\")\n+\t}\n+\n+\t// Build request from VM\n+\treq, err := c.buildRequest(vm, currentStepName)\n+\tif err != nil {\n+\t\treturn Summary{}, fmt.Errorf(\"failed to build request: %w\", err)\n+\t}\n+\n+\t// Marshal request\n+\treqBody, err := json.Marshal(req)\n+\tif err != nil {\n+\t\treturn Summary{}, fmt.Errorf(\"failed to marshal request: %w\", err)\n+\t}\n+\n+\t// Create HTTP request\n+\thttpReq, err := http.NewRequestWithContext(ctx, http.MethodPost,\n+\t\tc.baseURL+\"/api/summarize\", bytes.NewBuffer(reqBody))\n+\tif err != nil {\n+\t\treturn Summary{}, fmt.Errorf(\"failed to create request: %w\", err)\n+\t}\n+\n+\thttpReq.Header.Set(\"Content-Type\", \"application/json\")\n+\tif c.authToken != \"\" {\n+\t\thttpReq.Header.Set(\"Authorization\", \"Bearer \"+c.authToken)\n+\t}\n+\n+\t// Send request\n+\tresp, err := c.httpClient.Do(httpReq)\n+\tif err != nil {\n+\t\treturn Summary{}, fmt.Errorf(\"HTTP request failed: %w\", err)\n+\t}\n+\tdefer resp.Body.Close()\n+\n+\tif resp.StatusCode < 200 || resp.StatusCode >= 300 {\n+\t\tbody, _ := io.ReadAll(resp.Body)\n+\t\treturn Summary{}, fmt.Errorf(\"non-2xx response (%d): %s\", resp.StatusCode, string(body))\n+\t}\n+\n+\t// Parse response\n+\tvar apiResp contextMemorySummarizeResponse\n+\tif err := json.NewDecoder(resp.Body).Decode(&apiResp); err != nil {\n+\t\treturn Summary{}, fmt.Errorf(\"failed to decode response: %w\", err)\n+\t}\n+\n+\treturn Summary{\n+\t\tSubject:      apiResp.Subject,\n+\t\tBody:         apiResp.Body,\n+\t\tSummaryLine:  apiResp.Summary,\n+\t\tAnalysisHtml: apiResp.AnalysisHtml,\n+\t\tStatusHtml:   apiResp.StatusHtml,\n+\t\tStatus:       apiResp.Status,\n+\t}, nil\n+}\n+\n+func (c *ContextMemorySummarizer) buildRequest(vm *VM, currentStepName string) (*contextMemorySummarizeRequest, error) {\n+\tvm.mu.Lock()\n+\tdefer vm.mu.Unlock()\n+\n+\t// Extract workflow context\n+\tvar ownerEOA, smartWallet, workflowName, chainName string\n+\tif wfCtx, ok := vm.vars[WorkflowContextVarName].(map[string]interface{}); ok {\n+\t\tif owner, ok := wfCtx[\"owner\"].(string); ok {\n+\t\t\townerEOA = owner\n+\t\t}\n+\t\tif runner, ok := wfCtx[\"runner\"].(string); ok {\n+\t\t\tsmartWallet = runner\n+\t\t}\n+\t\tif eoa, ok := wfCtx[\"eoaAddress\"].(string); ok && eoa != \"\" && ownerEOA == \"\" {\n+\t\t\townerEOA = eoa\n+\t\t}\n+\t}\n+\t// Prioritize settings.name for workflow name (most accurate source)\n+\tif settings, ok := vm.vars[\"settings\"].(map[string]interface{}); ok {\n+\t\tif name, ok := settings[\"name\"].(string); ok && strings.TrimSpace(name) != \"\" {\n+\t\t\tworkflowName = name\n+\t\t}\n+\t\tif chain, ok := settings[\"chain\"].(string); ok {\n+\t\t\tchainName = chain\n+\t\t}\n+\t\tif runner, ok := settings[\"runner\"].(string); ok && smartWallet == \"\" {\n+\t\t\tsmartWallet = runner\n+\t\t}\n+\t}\n+\n+\t// Fallback to TaskOwner if available (for single node executions)\n+\tif ownerEOA == \"\" && vm.TaskOwner != (common.Address{}) {\n+\t\townerEOA = vm.TaskOwner.Hex()\n+\t}\n+\n+\t// Validate that workflow name is set (required - no fallbacks)\n+\tif workflowName == \"\" {\n+\t\treturn nil, fmt.Errorf(\"workflow name is required in settings.name\")\n+\t}\n+\n+\t// Convert execution logs to steps\n+\tsteps := make([]contextMemoryStepDigest, 0, len(vm.ExecutionLogs))\n+\tfor _, log := range vm.ExecutionLogs {\n+\t\tstep := contextMemoryStepDigest{\n+\t\t\tName:    log.GetName(),\n+\t\t\tID:      log.GetId(),\n+\t\t\tType:    log.GetType(),\n+\t\t\tSuccess: log.GetSuccess(),\n+\t\t}\n+\t\tif log.GetError() != \"\" {\n+\t\t\tstep.Error = log.GetError()\n+\t\t}\n+\t\t// Extract contract call info from ContractRead or ContractWrite\n+\t\tif contractRead := log.GetContractRead(); contractRead != nil {\n+\t\t\t// ContractRead doesn't have contract address/method in the output\n+\t\t\t// These would be in the node config, but we'll skip for now\n+\t\t}\n+\t\tif contractWrite := log.GetContractWrite(); contractWrite != nil {\n+\t\t\t// ContractWrite output doesn't contain contract address/method directly\n+\t\t\t// These would be in the node config, but we'll skip for now\n+\t\t}\n+\t\t// Extract output data\n+\t\tif contractRead := log.GetContractRead(); contractRead != nil && contractRead.Data != nil {\n+\t\t\tstep.OutputData = contractRead.Data.AsInterface()\n+\t\t}\n+\t\tif contractWrite := log.GetContractWrite(); contractWrite != nil && contractWrite.Data != nil {\n+\t\t\tstep.OutputData = contractWrite.Data.AsInterface()\n+\t\t}\n+\t\tif log.GetMetadata() != nil {\n+\t\t\tstep.Metadata = log.GetMetadata().AsInterface()\n+\t\t}\n+\t\t// Extract ExecutionContext (actual execution mode: is_simulated, provider, chain_id)\n+\t\tif log.GetExecutionContext() != nil {\n+\t\t\tstep.ExecutionContext = log.GetExecutionContext().AsInterface()",
        "body": "Missing error handling for structpb.NewValue conversion. If the ExecutionContext conversion to structpb.Value fails (line 221-222), the error is silently ignored and ExecutionContext is simply not set on the step. This could make debugging harder if the conversion fails due to unsupported data types in the ExecutionContext. Consider logging a warning if the conversion fails: `if log.GetExecutionContext() != nil { if ctxInterface := log.GetExecutionContext().AsInterface(); ctxInterface != nil { step.ExecutionContext = ctxInterface } }`\n```suggestion\n\t\t\tif ctxInterface := log.GetExecutionContext().AsInterface(); ctxInterface != nil {\n\t\t\t\tstep.ExecutionContext = ctxInterface\n\t\t\t}\n```",
        "created_at": "2026-01-09T22:02:06Z",
        "user": "copilot-pull-request-reviewer"
      },
      {
        "id": "PRRC_kwDOLqYZns6fmxf8",
        "path": "docs/context-memory-integration.md",
        "line": 34,
        "diff_hunk": "@@ -0,0 +1,279 @@\n+# Context Memory Integration Guide\n+\n+## Overview\n+\n+This document describes how to integrate the Go aggregator with the `context-api` service for AI-powered workflow summarization. The `context-api` service provides a REST API for generating execution summaries and managing workflow context.\n+\n+## Production Endpoint\n+\n+**Base URL**: `https://context-api.avaprotocol.org`\n+\n+The production URL is defined as a constant (`ContextAPIURL`) in `core/taskengine/summarizer_context_memory.go` and is used by default. It can be overridden via the `CONTEXT_MEMORY_URL` environment variable.\n+\n+## Authentication\n+\n+The aggregator must authenticate using a Bearer token:\n+```\n+Authorization: Bearer <SERVICE_AUTH_TOKEN>\n+```\n+\n+The `SERVICE_AUTH_TOKEN` should be configured in the aggregator's environment or config.\n+\n+## Integration Tests\n+\n+### Prerequisites\n+\n+1. **SERVICE_AUTH_TOKEN**: Authentication token for the context-api service\n+   - For production: Configured in your environment or aggregator config\n+   - For local: Check your `.env.local` file in the context-memory project\n+   - You can find it in the Vercel dashboard under Environment Variables\n+\n+2. **API URL**: The tests can run against either:\n+   - **Production**: `https://context-api.avaprotocol.org` (default)\n+   - **Local**: `http://localhost:3000` (set `CONTEXT_MEMORY_URL` env var)\n+   - **Custom**: Any URL via `CONTEXT_MEMORY_URL` env var",
        "body": "The documentation states that integration tests use the production URL by default (line 32), but the code actually defaults to the `ContextAPIURL` constant which might not be accessible in test files. Verify that `ContextAPIURL` is exported and accessible, or update the documentation to clarify that the constant defined in `summarizer_context_memory.go` is used as the default.",
        "created_at": "2026-01-09T22:02:06Z",
        "user": "copilot-pull-request-reviewer"
      },
      {
        "id": "PRRC_kwDOLqYZns6fmxgJ",
        "path": "core/taskengine/summarizer.go",
        "line": 612,
        "diff_hunk": "@@ -535,20 +555,58 @@ func normalizeBranchType(t string) string {\n }\n \n // buildBareHTMLFromText converts plain text into minimal HTML paragraphs without global styles\n+// Preserves safe HTML tags (<strong>, <em>, <br/>, etc.) while escaping potentially dangerous content\n func buildBareHTMLFromText(body string) string {\n-\t// Escape HTML to avoid injection\n-\tsafe := html.EscapeString(body)\n-\t// Normalize newlines\n-\tsafe = strings.ReplaceAll(safe, \"\\r\\n\", \"\\n\")\n+\t// Normalize newlines first\n+\tnormalized := strings.ReplaceAll(body, \"\\r\\n\", \"\\n\")\n+\n+\t// Check if body already contains HTML tags (from AI summaries)\n+\t// If it does, preserve safe HTML tags and only escape unsafe content\n+\thasHTML := strings.Contains(normalized, \"<\") && strings.Contains(normalized, \">\")\n+\n+\tif hasHTML {\n+\t\t// Body already contains HTML - preserve safe tags and escape only unsafe content\n+\t\t// First, temporarily replace safe HTML tags with placeholders\n+\t\tsafeTags := map[string]string{\n+\t\t\t\"<strong>\":  \"___STRONG_OPEN___\",\n+\t\t\t\"</strong>\": \"___STRONG_CLOSE___\",\n+\t\t\t\"<em>\":      \"___EM_OPEN___\",\n+\t\t\t\"</em>\":     \"___EM_CLOSE___\",\n+\t\t\t\"<br/>\":     \"___BR___\",\n+\t\t\t\"<br>\":      \"___BR___\",\n+\t\t}\n+\n+\t\t// Replace safe tags with placeholders\n+\t\twithPlaceholders := normalized\n+\t\tfor tag, placeholder := range safeTags {\n+\t\t\twithPlaceholders = strings.ReplaceAll(withPlaceholders, tag, placeholder)\n+\t\t}\n+\n+\t\t// Escape all remaining HTML (potentially dangerous)\n+\t\tsafe := html.EscapeString(withPlaceholders)\n+\n+\t\t// Restore safe tags\n+\t\tfor tag, placeholder := range safeTags {\n+\t\t\tsafe = strings.ReplaceAll(safe, placeholder, tag)\n+\t\t}\n+\n+\t\tnormalized = safe\n+\t} else {\n+\t\t// Plain text - escape everything\n+\t\tnormalized = html.EscapeString(normalized)\n+\t}\n+\n \t// Split by paragraphs (double newline)\n-\tparts := strings.Split(safe, \"\\n\\n\")\n+\tparts := strings.Split(normalized, \"\\n\\n\")\n \tvar paragraphs []string\n \tfor _, p := range parts {\n \t\tif strings.TrimSpace(p) == \"\" {\n \t\t\tcontinue\n \t\t}\n-\t\t// Convert single newlines within a paragraph to <br/>\n-\t\tp = strings.ReplaceAll(p, \"\\n\", \"<br/>\")\n+\t\t// Convert single newlines within a paragraph to <br/> (only if not already HTML)\n+\t\tif !hasHTML {\n+\t\t\tp = strings.ReplaceAll(p, \"\\n\", \"<br/>\")\n+\t\t}\n \t\tparagraphs = append(paragraphs, \"<p>\"+p+\"</p>\")\n \t}\n \treturn strings.Join(paragraphs, \"\\n\")",
        "body": "The HTML sanitization logic has a potential security vulnerability. The code uses a simple string replacement approach to preserve safe HTML tags, but this can be bypassed. For example, an attacker could inject `<strong onclick=\"alert('xss')\">` which would pass through because only the tag name is checked, not attributes. Additionally, the check `hasHTML := strings.Contains(normalized, \"<\") && strings.Contains(normalized, \">\")` could be fooled by legitimate text containing comparison operators. Consider using a proper HTML sanitizer library like `github.com/microcosm-cc/bluemonday` instead of rolling your own sanitization logic.",
        "created_at": "2026-01-09T22:02:06Z",
        "user": "copilot-pull-request-reviewer"
      },
      {
        "id": "PRRC_kwDOLqYZns6fmxgT",
        "path": "core/taskengine/vm_runner_rest.go",
        "line": 818,
        "diff_hunk": "@@ -807,10 +807,15 @@ func (r *RestProcessor) Execute(stepID string, node *avsproto.RestAPINode) (*avs\n \t\t\t\t\t\tdynamicData[\"branchSelections\"] = branchSelections\n \t\t\t\t\t}\n \n+\t\t\t\t\t// Check if we have an AI summary (from context-memory or OpenAI)\n+\t\t\t\t\t// If so, use it as-is (pass-through) instead of overwriting with deterministic summary\n+\t\t\t\t\thasAISummary := strings.TrimSpace(summaryForClient.Subject) != \"\" && strings.TrimSpace(summaryForClient.Body) != \"\"\n+\n \t\t\t\t\t// Compose deterministic branch/skip summary strings\n \t\t\t\t\t// When branches/skips are present, use the structured summary as the primary analysisHtml\n \t\t\t\t\t// Pass currentNodeName so BuildBranchAndSkippedSummary uses the same calculation logic\n-\t\t\t\t\tif !isSingleNodeImmediate(r.vm) {\n+\t\t\t\t\t// BUT: Skip this if we have an AI summary (context-memory) - use original response as pass-through\n+\t\t\t\t\tif !isSingleNodeImmediate(r.vm) && !hasAISummary {",
        "body": "The condition for determining whether to use AI summary pass-through is fragile. The check `hasAISummary := strings.TrimSpace(summaryForClient.Subject) != \"\" && strings.TrimSpace(summaryForClient.Body) != \"\"` (lines 811-812) relies on both Subject and Body being non-empty. However, it's possible for a valid AI summary to have an empty Subject but populated AnalysisHtml or StatusHtml fields. Consider also checking for AnalysisHtml: `hasAISummary := (strings.TrimSpace(summaryForClient.Subject) != \"\" || strings.TrimSpace(summaryForClient.AnalysisHtml) != \"\") && strings.TrimSpace(summaryForClient.Body) != \"\"`",
        "created_at": "2026-01-09T22:02:06Z",
        "user": "copilot-pull-request-reviewer"
      },
      {
        "id": "PRRC_kwDOLqYZns6fmxgV",
        "path": "core/taskengine/vm_runner_rest.go",
        "line": 943,
        "diff_hunk": "@@ -916,6 +921,42 @@ func (r *RestProcessor) Execute(stepID string, node *avsproto.RestAPINode) (*avs\n \t\t\t\t\t\t\tpreheader := extractPreheaderFromSummaryText(text, newSubject)\n \t\t\t\t\t\t\tdynamicData[\"preheader\"] = preheader\n \t\t\t\t\t\t}\n+\t\t\t\t\t} else if hasAISummary {\n+\t\t\t\t\t\t// Use original AI summary (context-memory) as pass-through\n+\t\t\t\t\t\t// Keep original subject/body/analysisHtml from context-memory\n+\t\t\t\t\t\t// Use statusHtml from context-memory if available, otherwise generate locally\n+\t\t\t\t\t\tif r.vm.logger != nil {\n+\t\t\t\t\t\t\tr.vm.logger.Info(\"Using AI summary as pass-through\", \"subject\", summaryForClient.Subject, \"hasStatusHtml\", summaryForClient.StatusHtml != \"\")\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t// Use statusHtml from context-memory if available\n+\t\t\t\t\t\tif summaryForClient.StatusHtml != \"\" {\n+\t\t\t\t\t\t\tdynamicData[\"statusHtml\"] = summaryForClient.StatusHtml\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t// Fallback: Generate minimal statusHtml for email template (based on workflow success)\n+\t\t\t\t\t\t\tfailed, _, _ := findEarliestFailure(r.vm)\n+\t\t\t\t\t\t\tvar statusHtml string\n+\t\t\t\t\t\t\tif failed {\n+\t\t\t\t\t\t\t\tstatusHtml = `<div style=\"display:inline-block; padding:8px 16px; background-color:#FEE2E2; color:#991B1B; border-radius:8px; font-weight:500; margin:8px 0\"><svg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\" style=\"vertical-align:middle; margin-right:6px\"><circle cx=\"8\" cy=\"8\" r=\"7\" fill=\"#EF4444\"/><path d=\"M10 6L6 10M6 6L10 10\" stroke=\"white\" stroke-width=\"2\" stroke-linecap=\"round\"/></svg>Execution failed</div>`\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\tstatusHtml = `<div style=\"display:inline-block; padding:8px 16px; background-color:#D1FAE5; color:#065F46; border-radius:8px; font-weight:500; margin:8px 0\"><svg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\" style=\"vertical-align:middle; margin-right:6px\"><circle cx=\"8\" cy=\"8\" r=\"7\" fill=\"#10B981\"/><path d=\"M11 6L7 10L5 8\" stroke=\"white\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/></svg>All steps completed successfully</div>`\n+\t\t\t\t\t\t\t}",
        "body": "Hardcoded inline SVG and styles in status HTML create maintainability issues. The statusHtml fallback on lines 940 and 942 contains large inline HTML strings with embedded SVG icons and styles. This makes the code harder to read and maintain. If the design needs to change (e.g., icon colors, sizes, or styling), developers must search through Go code to find these strings. Consider extracting these HTML templates to constants at the package level or using a template system.",
        "created_at": "2026-01-09T22:02:07Z",
        "user": "copilot-pull-request-reviewer"
      }
    ],
    "issue_comments": []
  },
  "claude": {
    "review_comments": [],
    "issue_comments": []
  }
}
