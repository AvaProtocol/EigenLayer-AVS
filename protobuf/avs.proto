syntax = "proto3";
package aggregator;

option go_package = "./avsproto";

import "google/protobuf/timestamp.proto";
import "google/protobuf/wrappers.proto";

message UUID {
  string bytes = 1;
}

message Checkin {
  string id = 1;
  string address = 2;
  string signature = 3;

  message Status {
    int64 uptime = 1;
    int64 queueDepth = 2;
    google.protobuf.Timestamp last_heartbeat = 3;
  }

  Status status = 4;

  string version = 5;
  int32 metricsPort = 6;
  string remoteIP = 7;
}

message CheckinResp {
  google.protobuf.Timestamp updated_at = 1;
}

message SyncTasksReq {
  string id = 1;
  string address = 2;
  string signature = 3;
  int64  monotonic_clock = 4;
}

enum TriggerType {
  ManualTrigger        = 0;
  FixedEpochTrigger  = 1;
  CronTrigger        = 2;
  BlockTrigger       = 3;
  EventTrigger         = 4;
}

message FixedEpochCondition {
  repeated int64 at_epoches = 1;
}
// Simple timebase or cron syntax.
message CronCondition {
  repeated string cron_table = 1;
}

message BlockCondition {
  int64 interval = 1;
}

// An arbitrary expression to express the condition.
// People can define condition example
//   chainlinkPrice("address-of-eth-usd-pair") > 2644500 && queryContract("contractaddress", "callmsg")[2] < = 5
// By allow arbitrary expression, people can mix and match to create conplex
// condition that match their workload
//
// The function to be used need to be pre-defined on our task egnine runtime.
// When a new block is build, our engine will execute these check
//
// The expression language is re-present by https://expr-lang.org/
message EventCondition {
  string expression = 1;
}

message TaskTrigger {
  TriggerType            trigger_type   = 1;

  oneof trigger_condition {
    bool        manual     = 2;

    // run at a specific epoch, name inspired by unix `at` utility
    FixedEpochCondition    at      = 3;

    // interval such as every hour/day/ etc can be converted to cronsyntax by the sdk/studio
    CronCondition          cron       = 4;
   
    // currently the only support syntax is every <x> blocks
    BlockCondition         block      = 5;

    // support filter by event expression such as topic0, topic1, topoc2 and event_data and contract_address
    EventCondition         event      = 6;
  }
}

// gRPC internal error code use up to 17, we extend and start from 1000 to avoid any conflict 
// Guide: https://grpc.io/docs/guides/error/
// Go: https://github.com/grpc/grpc-go/blob/master/codes/codes.go#L199
enum Error {
  // An error that happen when the app can be recovered but the cause is unknow, rarely use, we try to use specific error as much as we can
  UnknowError              = 0;
  // internal rpc node error
  RpcNodeError             = 1000;
  // storage system isn't available to respond to query
  StorageUnavailable       = 2000;
  StorageWriteError        = 2001;
  // target chain of smart wallet is error and cannot used to determine smartwallet info
  SmartWalletRpcError      = 6000;
  SmartWalletNotFoundError = 6001;

  // Error occurs when we failed to migrate task data and it cannot be decode
  TaskDataCorrupted = 7000;
  TaskDataMissingError = 7001;
}


message SyncTasksResp {
  string id        = 1;
  string checkType = 2;

  TaskTrigger trigger = 3;
}

// TaskType represents what kind of work the task will perform
enum TaskType {
  // Handle default/missing data
  ETHTransferTask = 0;
  
  // Generic contract execution which can be used for:
  // ERC20 Transfer, NFT Transfer, auto reclaim, auto restaking etc
  // When executing a contract we need at least 2 things:
  // - target contract address
  // - the message to send to that contract
  ContractWriteTask = 1;
  ContractReadTask  = 2;

  // GraphQL query. Note that a graphql can also be query as a HTTP API, but having its own graphql type make writing query easiser without passing all the data in post as parameter.
  GraphQLDataQueryTask = 3;

  // Make call to a HTTP endpoint
  HTTPAPICallTask = 4;

  // CustomCode allow to run arbitraty JavaScript.
  BranchTask = 5;
  FilterTask = 6;
  CustomCodeTask = 7;
}

// TaskStatus represents status of the task. The transition is as follow
enum TaskStatus {
  Active = 0;
  Completed = 1;
  Failed = 2;
  Canceled = 3;
  Executing = 4;
}

message ETHTransferNode {
  string destination = 1;
  string amount = 2;
}

message ContractWriteNode {
  string contract_address = 1;
  string call_data = 2;

  // abi is necessary to decode the return
  string contract_abi = 3;
}

message ContractQueryNode {
  string contract_address = 1;
  string call_data = 2;

  // abi is necessary to decode the return
  string contract_abi = 3;
}


message GraphQLQueryNode {
  // TODO: support graphql variable
  string url   = 1;
  string query = 2;
}

message HTTPAPINode {
  string              url     = 1;
  map<string, string> headers = 2;
  string              body    = 3;
}

enum CustomCodeType {
  JavaScript = 0;
}

message CustomCodeNode {
  CustomCodeType type     = 1;
  string         source    = 2;
}

message ConditionJump {
  string expression  = 1;
  string next        = 2;
}

message BranchNode {
  ConditionJump If                  = 1;
  repeated ConditionJump ElseIfs    = 2;
  ConditionJump Else                = 3;
}

message FilterNode {
  // Filter node acts like .select or .filter to pluck out element in an array that evaluate the expression to true
  string expression = 1;
}

// The edge is relationship or direct between node
message TaskEdge {
  string id    = 1 ;
  string start = 2 ;
  string end   = 3 ; 
}

message TaskNode {
  TaskType node_type = 1;
  string id   = 2;
  string name = 3;

  // based on node_type one and only one of these field are set
  oneof task_body {
    // Transfer eth require no calldata etc, just a destination address and an eth amount to be sent
    ETHTransferNode       eth_transfer = 10;

    // Run one ore more contracts. The call call also be batched with tool like
    // multicall to wrap many calls. in a contract write, we need to generate signature and send as userops.
    ContractWriteNode     contract_write = 11;
    // read data fron a target contract
    ContractQueryNode     contract_read = 12;
    // Make call to a graphql endpoint
    GraphQLQueryNode  graphql_data_query = 13;
    // Make call to a HTTP endpoint
    HTTPAPINode       http_data_query = 14;
    // CustomCode allow to run arbitraty JavaScript.
    BranchNode      branch = 15;
    FilterNode        filter = 16;
    CustomCodeNode        custom_code = 17;
  }
}

message Execution {
  int64  epoch        = 1;
  string user_op_hash = 2;
  string error        = 3;
}

message Task {
  UUID   id                   = 1;
  string owner                = 2;
  string smart_wallet_address = 3;

  // task won't be check before this
  int64  start_at   = 5;
  // task won't be run/check after this
  int64  expired_at = 6;
  // arbitrary data about this task. has a limit of 255 character
  string memo = 7;

  int64 completed_at = 8;

  // repeatable means a task can continue to run even after the first execution.
  // By default, recurring is false, task will only executed once.
  bool recurring  = 10;

  TaskStatus status  = 9;
  TaskTrigger trigger = 4;
  repeated TaskNode nodes = 11;
  repeated TaskEdge edges = 12;

  repeated Execution executions = 13;
}


message CreateTaskReq {
  TaskTrigger trigger          = 1;

  int64 start_at               = 2;
  int64 expired_at             = 3;

  // A repeatable task will continue to be run
  bool repeatable              = 4;

  // the smart wallet address that will be used to run this task
  // When leaving out, we will use the default(salt=0) wallet
  string smart_wallet_address  = 5;

  string memo                  = 6;
  repeated TaskNode nodes      = 7;
  repeated TaskEdge edges      = 8;
}

message CreateTaskResp {
  string id = 1;
}

message NonceRequest {
  string owner = 1;
}

message NonceResp {
  string nonce = 1;
}

message AddressRequest {
  // filter out by factory address or salt
  // otherwise return all the wallet
  string factory = 1;
  string salt = 2;
}

message SmartWallet {
  string address = 1;
  string salt = 2;
  string factory = 3;
}

message AddressResp {
  repeated SmartWallet wallets = 1;
}


message ListTasksReq {
  // Filter out by the smart_wallet_address
  string smart_wallet_address = 1;
}

message ListTasksResp {
  repeated Task tasks = 1;
}

message GetKeyReq {
  string owner = 1;
  int64  expired_at = 2;
  string signature = 3;
}

message KeyResp {
  string key=1;
}

message UpdateChecksReq {
  string address = 1;
  string signature = 2;
  repeated string id = 3;
}

message UpdateChecksResp {
  google.protobuf.Timestamp updated_at = 1;
}

message CreateWalletReq {
  string salt = 1;
  // this is the factory address for the wallet, when leaving its empty, we will use our default factory address
  string factory_address = 2;
}

message CreateWalletResp {
  string address = 1;
}

service Aggregator {
  // Auth
  rpc GetKey(GetKeyReq) returns (KeyResp) {};

  // Smart Acccount
  rpc GetNonce(NonceRequest)                 returns (NonceResp) {};
  rpc GetSmartAccountAddress(AddressRequest) returns (AddressResp) {};

  // Task Management
  rpc CreateWallet(CreateWalletReq) returns (CreateWalletResp) {};
  rpc CreateTask(CreateTaskReq)     returns (CreateTaskResp) {};
  rpc ListTasks(ListTasksReq)       returns (ListTasksResp) {};
  rpc GetTask(UUID)                 returns (Task) {};
  rpc CancelTask(UUID)              returns (google.protobuf.BoolValue) {};
  rpc DeleteTask(UUID)              returns (google.protobuf.BoolValue) {};

  // Operator endpoint
  rpc Ping(Checkin) returns (CheckinResp) {};
  rpc SyncTasks(SyncTasksReq) returns (stream SyncTasksResp) {};
  rpc UpdateChecks(UpdateChecksReq) returns (UpdateChecksResp) {};
}
