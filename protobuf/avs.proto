syntax = "proto3";
package aggregator;

option go_package = "./avsproto";

import "google/protobuf/wrappers.proto";
import "google/protobuf/any.proto";
import "google/protobuf/struct.proto";

// ============================================================================
// ENUMS - Single source of truth for types
// ============================================================================

// TriggerType defines all supported trigger types
// This enum provides a single source of truth for trigger types used across the system
enum TriggerType {
  TRIGGER_TYPE_UNSPECIFIED = 0;  // Default unspecified value
  TRIGGER_TYPE_MANUAL = 1;       // Manual trigger
  TRIGGER_TYPE_FIXED_TIME = 2;   // Fixed time trigger
  TRIGGER_TYPE_CRON = 3;         // Cron-based trigger
  TRIGGER_TYPE_BLOCK = 4;        // Block-based trigger
  TRIGGER_TYPE_EVENT = 5;        // Event-based trigger
}

// NodeType defines all supported node types
// This enum provides a single source of truth for node types used across the system
enum NodeType {
  NODE_TYPE_UNSPECIFIED = 0;     // Default unspecified value
  NODE_TYPE_ETH_TRANSFER = 1;    // Ethereum transfer node
  NODE_TYPE_CONTRACT_WRITE = 2;  // Contract write node
  NODE_TYPE_CONTRACT_READ = 3;   // Contract read node
  NODE_TYPE_GRAPHQL_QUERY = 4;   // GraphQL query node
  NODE_TYPE_REST_API = 5;        // REST API node
  NODE_TYPE_CUSTOM_CODE = 6;     // Custom code node
  NODE_TYPE_BRANCH = 7;          // Branch node
  NODE_TYPE_FILTER = 8;          // Filter node
  NODE_TYPE_LOOP = 9;            // Loop node
}

enum ExecutionMode {
  EXECUTION_MODE_SEQUENTIAL = 0;  // Run iterations sequentially (default for safety)
  EXECUTION_MODE_PARALLEL = 1;    // Run iterations in parallel
}

// ============================================================================
// TOKEN METADATA MESSAGES
// ============================================================================

// TokenMetadata represents ERC20 token information
message TokenMetadata {
  string address = 1;    // Contract address (lowercase, normalized)
  string name = 2;       // Token name (e.g., "USD Coin")
  string symbol = 3;     // Token symbol (e.g., "USDC")
  uint32 decimals = 4;   // Number of decimal places
}

// GetTokenMetadataReq is the request for token metadata lookup
message GetTokenMetadataReq {
  string address = 1;    // Contract address to look up
}

// GetTokenMetadataResp is the response containing token metadata
message GetTokenMetadataResp {
  TokenMetadata token = 1;  // Token metadata information
  bool found = 2;           // Whether the token was found
  string source = 3;        // Source of data: "whitelist", "rpc", or "cache"
}

// ============================================================================
// CLIENT-FACING MESSAGES
// ============================================================================

// TRIGGER AND NODE INPUT SYSTEM:
// 
// All triggers and nodes now support an `input` field of type google.protobuf.Value,
// which stores user-provided input data as JavaScript objects. This data is available
// for reference by subsequent nodes during task execution.
//
// During task execution, both the output data and input data of each step are accessible:
// - `node_name.data` or `node_name.output` - The computed output from the node execution
// - `node_name.input` - The user-provided input data defined when the task/node was created
//
// This allows for flexible data flow where:
// 1. Static configuration is stored in the Config field
// 2. User-provided runtime data is stored in the input field  
// 3. Computed results are available in the Output field
//
// Example usage in SimulateTask or CreateTask:
// - Define input data for each node/trigger when creating the task
// - Reference both computed outputs and input data in subsequent nodes
// - Use expressions like `${previous_node.data.result}` and `${previous_node.input.user_value}`

message IdReq {
  string id = 1;
}

enum Lang {
  JavaScript = 0;
}

// Triggers are always the first element in a task execution flow
// They have Config (static parameters) but no Input (no preceding nodes)

message FixedTimeTrigger {
  message Config {
    repeated int64 epochs = 1;
  }
  
  message Output {
    google.protobuf.Value data = 1;
  }

  // Include Config as field so it is generated in Go
  Config config = 1;
}

// Simple timebase or cron syntax.
message CronTrigger {
  message Config {
    repeated string schedules = 1;
  }
  
  message Output {
    google.protobuf.Value data = 1;
  }

  // Include Config as field so it is generated in Go
  Config config = 1;
}

message BlockTrigger {
  message Config {
    int64 interval = 1;
  }
  
  message Output {
    google.protobuf.Value data = 1;
  }

  // Include Config as field so it is generated in Go
  Config config = 1;
}

// EventTrigger monitors blockchain events using direct RPC filter queries.
// Clients provide an array of ethereum.FilterQuery structures that map directly to RPC calls.
// This approach eliminates parsing overhead and provides maximum flexibility and performance.
message EventTrigger {
  // Query represents a single ethereum.FilterQuery for RPC filtering
  message Query {
    // Contract addresses to filter events from. Empty means any contract.
    repeated string addresses = 1;
    
    // Topic filters structured as a 2D array matching ethereum.FilterQuery.Topics
    // Each inner array represents a topic position (topic[0], topic[1], topic[2], etc.)
    // Each string in the inner array represents a valid value for that topic position
    // Empty inner array means "any value" for that topic position
    // 
    // Example for Transfer events FROM or TO a specific address:
    // [
    //   ["0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef"], // Transfer signature
    //   ["0x000000000000000000000000fE66125343Aabda4A330DA667431eC1Acb7BbDA9"], // FROM address
    //   []  // Any TO address
    // ]
    repeated Topics topics = 2;
    
    // Maximum number of events this query should process per block/time window
    // Used for safety - if exceeded, operator notifies aggregator to cancel task
    optional uint32 max_events_per_block = 3;
    
    // Contract ABI as JSON string (converted from array input)
    string contract_abi = 4;
    
    // Event conditions to evaluate on decoded event data
    repeated EventCondition conditions = 5;
    
    // Method calls for enhanced event data formatting (e.g., decimals, description)
    repeated MethodCall method_calls = 6;
  }
  
  // Method call configuration for enhanced formatting
  message MethodCall {
    string method_name = 1;       // Method name (e.g., "decimals")
    string call_data = 2;         // Hex-encoded calldata for the method
    repeated string apply_to_fields = 3;  // Fields to apply formatting to (e.g., ["current", "answer"])
  }
  
  // Topics represents a single topic position filter (e.g., topic[0], topic[1], etc.)
  message Topics {
    repeated string values = 1;  // Valid values for this topic position
  }

  message Config {
    // Array of RPC filter queries. Each query creates a separate subscription.
    // For FROM-OR-TO scenarios, provide two queries: one for FROM, one for TO.
    repeated Query queries = 1;
  }
  
  message Output {
    google.protobuf.Value data = 1;  // Parsed event data as structured value
  }

  // Include Config as field so it is generated in Go
  Config config = 1;
}

message ManualTrigger {
  message Config {
    // User-defined data that will be returned in the Output
    google.protobuf.Value data = 1;
    // Headers for webhook testing - map format consistent with REST API nodes
    map<string, string> headers = 2;
    // Path parameters for webhook testing - map format consistent with REST API nodes
    map<string, string> pathParams = 3;
  }
  
  message Output {
    // User-defined data from trigger config - this is the main payload for manual triggers
    google.protobuf.Value data = 1;
  }

  // Include Config as field so it is generated in Go
  Config config = 1;
}

message TaskTrigger {
  string name = 1;
  
  // NEW: Use the enum for type identification (Phase 1: add alongside existing)
  TriggerType type = 8;
  
  oneof trigger_type {
    // manual task with proper ManualTrigger structure for webhook testing
    ManualTrigger      manual = 2;
    
    // run at a specific epoch, name inspired by unix `at` utility
    FixedTimeTrigger fixed_time   = 3;

    // interval such as every hour/day/ etc can be converted to cronsyntax by the sdk/studio
    CronTrigger      cron    = 4;
   
    // currently the only support syntax is every <x> blocks
    BlockTrigger     block   = 5;

    // support filter by event expression such as topic0, topic1, topoc2 and event_data and contract_address
    EventTrigger     event   = 6;
  }
  string id = 7;
}

// gRPC internal error code use up to 17, we extend and start from 1000 to avoid any conflict 
// Guide: https://grpc.io/docs/guides/error/
// Go: https://github.com/grpc/grpc-go/blob/master/codes/codes.go#L199
// Unified error codes for client-server communication
// Maps to standard gRPC status codes where applicable, but provides domain-specific error details
enum ErrorCode {
  // Standard success - no error
  ERROR_CODE_UNSPECIFIED = 0;
  
  // 1000-1999: Authentication and Authorization errors  
  UNAUTHORIZED = 1000;              // Invalid or missing authentication
  FORBIDDEN = 1001;                 // Insufficient permissions
  INVALID_SIGNATURE = 1002;         // Signature verification failed
  EXPIRED_TOKEN = 1003;             // Auth token has expired
  
  // 2000-2999: Resource Not Found errors
  TASK_NOT_FOUND = 2000;            // Task/workflow not found
  EXECUTION_NOT_FOUND = 2001;       // Execution not found  
  WALLET_NOT_FOUND = 2002;          // Smart wallet not found
  SECRET_NOT_FOUND = 2003;          // Secret not found
  TOKEN_METADATA_NOT_FOUND = 2004;  // Token metadata not found
  
  // 3000-3999: Validation and Bad Request errors
  INVALID_REQUEST = 3000;           // General request validation failed
  INVALID_TRIGGER_CONFIG = 3001;    // Trigger configuration is invalid
  INVALID_NODE_CONFIG = 3002;       // Node configuration is invalid
  INVALID_WORKFLOW = 3003;          // Workflow structure is invalid
  INVALID_ADDRESS = 3004;           // Blockchain address format invalid
  INVALID_SIGNATURE_FORMAT = 3005;  // Signature format invalid
  MISSING_REQUIRED_FIELD = 3006;    // Required field is missing
  
  // 4000-4999: Resource State errors
  TASK_ALREADY_EXISTS = 4000;       // Task with same ID already exists
  TASK_ALREADY_COMPLETED = 4001;    // Cannot modify completed task
  TASK_ALREADY_CANCELLED = 4002;    // Cannot modify cancelled task
  EXECUTION_IN_PROGRESS = 4003;     // Operation not allowed during execution
  WALLET_ALREADY_EXISTS = 4004;     // Wallet already exists for salt
  SECRET_ALREADY_EXISTS = 4005;     // Secret with same name exists
  
  // 5000-5999: External Service errors
  RPC_NODE_ERROR = 5000;            // Blockchain RPC node error
  TENDERLY_API_ERROR = 5001;        // Tenderly simulation error
  TOKEN_LOOKUP_ERROR = 5002;        // Token metadata lookup failed
  SIMULATION_ERROR = 5003;          // Workflow simulation failed
  
  // 6000-6999: Internal System errors  
  STORAGE_UNAVAILABLE = 6000;       // Database/storage system unavailable
  STORAGE_WRITE_ERROR = 6001;       // Failed to write to storage
  STORAGE_READ_ERROR = 6002;        // Failed to read from storage
  TASK_DATA_CORRUPTED = 6003;       // Task data cannot be decoded
  EXECUTION_ENGINE_ERROR = 6004;    // Task execution engine error
  
  // 7000-7999: Rate Limiting and Quota errors
  RATE_LIMIT_EXCEEDED = 7000;       // API rate limit exceeded
  QUOTA_EXCEEDED = 7001;            // User quota exceeded
  TOO_MANY_REQUESTS = 7002;         // Too many concurrent requests
  
  // 8000-8999: Smart Wallet specific errors
  SMART_WALLET_RPC_ERROR = 8000;    // Smart wallet RPC call failed
  SMART_WALLET_NOT_FOUND = 8001;    // Smart wallet address not found
  SMART_WALLET_DEPLOYMENT_ERROR = 8002; // Failed to deploy smart wallet
  INSUFFICIENT_BALANCE = 8003;      // Insufficient balance for operation
  
  // 9000-9999: Reserved for future use
}


// TaskStatus represents status of the task. The transition is as follow
enum TaskStatus {
  Active    = 0;
  // Task is completd when it's reaching its max_execution or its expiration time
  Completed = 1;
  Failed    = 2;
  Canceled  = 3;
  Executing = 4;
}

// Execution Status re-present a run of the task
enum ExecutionStatus {
  EXECUTION_STATUS_UNSPECIFIED = 0;
  EXECUTION_STATUS_PENDING = 1;
  EXECUTION_STATUS_COMPLETED = 2;
  EXECUTION_STATUS_FAILED = 3;
}


// Nodes process data from preceding triggers/nodes
// They have both Config (static parameters) and Input (runtime variables)

message ETHTransferNode {
  message Config {
    string destination = 1;
    string amount = 2;
  }

  message Output {
    google.protobuf.Value data = 1;
  }

  // Include Config as field 
  Config config = 1;
}

message ContractWriteNode {
  message Config {
    string contract_address = 1;
    string call_data = 2;
    // The ABI as JSON string (converted from array input)
    string contract_abi = 3;
    // Support for multiple method calls in sequence (similar to ContractRead)
    repeated MethodCall method_calls = 4;
  }

  message MethodCall {
    string call_data = 1;     // Hex-encoded calldata for the method (used when methodParams is not provided)
    string method_name = 2;   // Method name for clarity and response mapping
    repeated string method_params = 3; // Array of Handlebars templates for method parameters (e.g. ["{{value.sender}}", "{{value.recipient}}", "{{value.amount}}"])
  }

  message Output {
    // Changed from repeated MethodResult to google.protobuf.Value for better JavaScript native type support
    // Data will be a JSON array of method results with enhanced response structure
    google.protobuf.Value data = 1;
  }

  message MethodResult {
    string method_name = 1;                   // The name of the method called
    google.protobuf.Value method_abi = 2;     // Complete ABI entry for this method
    bool success = 3;                         // Whether this specific method call succeeded
    string error = 4;                         // Error message if failed (empty if success)
    google.protobuf.Value receipt = 5;        // Flexible receipt as JSON object
    optional uint64 block_number = 6;         // Block number (duplicate from receipt for convenience)
    google.protobuf.Value value = 7;          // Return value from contract method (null if no return)
  }

  // Include Config as field 
  Config config = 1;
}

message ContractReadNode {
  message MethodCall {
    string call_data = 1;     // Hex-encoded calldata for the method (used when methodParams is not provided)
    string method_name = 2;   // Optional: method name for clarity (e.g. "latestRoundData")
    repeated string apply_to_fields = 3;  // Fields to apply decimal formatting to (e.g. ["answer"])
    repeated string method_params = 4; // Handlebars template for method parameters (e.g. "{{value.address}}")
  }

  message Config {
    string contract_address = 1;
    // The ABI as JSON string (converted from array input)
    string contract_abi = 2;
    // Array of method calls to execute serially
    repeated MethodCall method_calls = 3;
  }

  message MethodResult {
    // Structured data with named fields based on method signature
    message StructuredField {
      string name = 1;      // Field name from ABI (e.g. "roundId", "answer", "startedAt")
      string type = 2;      // Solidity type (e.g. "uint80", "int256", "uint256")
      string value = 3;     // The actual value as string, client parses based on type
    }
    repeated StructuredField data = 1;
    
    // Method metadata
    string method_name = 2;   // The name of the method called
    bool success = 3;         // Whether this specific method call succeeded
    string error = 4;         // Error message if the method call failed
  }

  message Output {
    // Changed from repeated MethodResult to google.protobuf.Value for better JavaScript native type support
    // Data will be a JSON array of method results with flattened key-value structure
    google.protobuf.Value data = 1;
  }

  // Include Config as field 
  Config config = 1;
}


message GraphQLQueryNode {
  message Config {
    // Static configuration set at node creation time
    string url = 1;
    string query = 2;
    map<string, string> variables = 3;
  }

  message Output {
    // The data is the result of the graphql query. Because this is GraphQL, the data is a json object
    // The field of the json object is unknown, it depends on the query
    google.protobuf.Value data = 1;
  }

  // Include Config as field 
  Config config = 1;
}

message RestAPINode {
  message Config {
    string url = 1;
    map<string, string> headers = 2;
    string body = 3;
    string method = 4;
  }

  message Output {
    // Changed from google.protobuf.Any to google.protobuf.Value for better JavaScript native type support
    google.protobuf.Value data = 1;
  }

  // Include Config as field 
  Config config = 1;
}

message CustomCodeNode {
  message Config {
    Lang lang = 1;  // Language is static config set at creation time
    string source = 2;  // Source code
  }

  message Output {
    // Changed from google.protobuf.Any to google.protobuf.Value for better JavaScript native type support
    google.protobuf.Value data = 1;
  }

  // Include Config as field 
  Config config = 1;
}

message BranchNode {
  message Condition {
    string id = 1;
    string type = 2;
    string expression = 3;
  }

  message Config {
    repeated Condition conditions = 1;
  }

  message Output {
    // the output of the branch node contains the condition evaluation results
    // the execution will continue to the next node belong to this condition 
    // In front-end, when rendering the historical execution, we can draw the relationship coming out of the condition that match this id
    google.protobuf.Value data = 1;
  }

  // Include Config as field 
  Config config = 1;
}

message FilterNode {
  message Config {
    // Filter node acts like .select or .filter to pluck out element in an array that evaluate the expression to true
    string expression = 1;
    
    // The name of the input node whose output data will be filtered.
    // The data should be iterable (array, object, etc.). Runtime validation will check compatibility.
    string input_node_name = 2;
  }

  message Output {
    // the output of the filter node is the filtered array after apply the filter expression. It works similar to filter of javascript
    google.protobuf.Value data = 1;
  }

  // Include Config as field 
  Config config = 1;
}

// LoopNode currently not support, but we pre-defined to reverse the field id
message LoopNode {
  message Config {
    // The name of the input node whose output data will be iterated over.
    string input_node_name = 1;
    // iter_val is the variable name that will hold the current value during each iteration
    string iter_val = 2;
    // iter_key is the variable name that will hold the current key/index during each iteration
    string iter_key = 3;
    // execution_mode determines whether iterations run in parallel or sequentially
    // Note: ContractWrite operations always run sequentially regardless of this setting
    ExecutionMode execution_mode = 4;
  }

  // inside the runner, it can access to the current value of the loop iteration through the iter_val/iter_key above
  oneof runner {
    // Transfer eth require no calldata etc, just a destination address and an eth amount to be sent
    ETHTransferNode   eth_transfer = 10;

    // Run one ore more contracts. The call call also be batched with tool like
    // multicall to wrap many calls. in a contract write, we need to generate signature and send as userops.
    ContractWriteNode contract_write = 11;
    // read data fron a target contract
    ContractReadNode  contract_read = 12;
    // Make call to a graphql endpoint
    GraphQLQueryNode  graphql_data_query = 13 ;
    // Make call to a HTTP endpoint
    RestAPINode       rest_api = 14;
    CustomCodeNode    custom_code = 15;
  }

  message Output {
    google.protobuf.Value data = 1;
  }

  // Include Config as field 
  Config config = 1;
}

// The edge is relationship or direct between node
message TaskEdge {
  string id     = 1 ;
  string source = 2 ;
  string target = 3 ; 
}

message TaskNode {
  string id   = 2;
  string name = 3;
  
  // NEW: Use the enum for type identification (Phase 1: add alongside existing)
  NodeType type = 1;

  // based on node_type one and only one of these field are set
  oneof task_type {
    // Transfer eth require no calldata etc, just a destination address and an eth amount to be sent
    ETHTransferNode   eth_transfer = 10;

    // Run one ore more contracts. The call call also be batched with tool like
    // multicall to wrap many calls. in a contract write, we need to generate signature and send as userops.
    ContractWriteNode contract_write = 11;
    // read data fron a target contract
    ContractReadNode contract_read = 12;
    // Make call to a graphql endpoint
    GraphQLQueryNode  graphql_query = 13;
    // Make call to a HTTP endpoint
    RestAPINode       rest_api = 14;
    // CustomCode allow to run arbitraty JavaScript.
    BranchNode        branch = 15;
    FilterNode        filter = 16;
    LoopNode          loop = 17;
    CustomCodeNode    custom_code = 18;
  }
}

message Execution {
  string id      = 1;
  
  int64 start_at = 2; // timestamp when execution started (in milliseconds)
  int64 end_at   = 3; // timestamp when execution ended (in milliseconds)
  bool   success = 4;
  string error   = 5;

  message Step {
    string id = 1;
    
    // Unified type field - can be trigger type (MANUAL, BLOCK, etc) or node type (CUSTOM_CODE, REST_API, etc)
    string type = 17;
    string name = 18;
    bool success = 2;
    string error = 13;
    string log = 12;
    repeated string inputs = 16;
    // Configuration data that was set on this trigger/node
    google.protobuf.Value config = 19;
    oneof output_data {
      // Trigger outputs
      BlockTrigger.Output block_trigger = 20;
      FixedTimeTrigger.Output fixed_time_trigger = 21;
      CronTrigger.Output cron_trigger = 22;
      EventTrigger.Output event_trigger = 23;
      ManualTrigger.Output manual_trigger = 24;
      
      // Node outputs  
      ETHTransferNode.Output eth_transfer = 3;
      GraphQLQueryNode.Output graphql = 4;
      ContractReadNode.Output contract_read = 5;
      ContractWriteNode.Output contract_write = 6;
      CustomCodeNode.Output custom_code = 7;
      RestAPINode.Output rest_api = 8;
      BranchNode.Output branch = 9;
      FilterNode.Output filter = 10;
      LoopNode.Output loop = 11;
    }
    
    // timestamp when step started (in milliseconds)
    int64 start_at = 14;
    // timestamp when step ended (in milliseconds)
    int64 end_at = 15;
  }

  repeated Step steps = 8;
}


message Task {
  string id                   = 1;
  string owner                = 2;
  string smart_wallet_address = 3;

  // task won't be check before this (timestamp in milliseconds)
  int64  start_at   = 4;
  // task won't be run/check after this (timestamp in milliseconds)
  int64  expired_at = 5;
  // arbitrary data about this task. has a limit of 255 character
  string name = 6;

  // timestamp when task was completed (in milliseconds)
  int64 completed_at = 7;

  // limit on how many time this task can run. Set to 0 will make it run unlimited until cancelling or reaching its expired time
  int64 max_execution = 8;
  // return how many time this task has run
  int64 execution_count = 9;
  // timestamp when task was last executed (in milliseconds)
  int64 last_ran_at = 10;

  TaskStatus status  = 11;
  TaskTrigger trigger = 12;
  repeated TaskNode nodes = 13;
  repeated TaskEdge edges = 14;
}


message CreateTaskReq {
  TaskTrigger trigger          = 1;

  int64 start_at               = 2;
  int64 expired_at             = 3;

  int64 max_execution          = 4;

  // the smart wallet address that will be used to run this task
  // When leaving out, we will use the default(salt=0) wallet
  string smart_wallet_address  = 5;

  string name                  = 6;
  repeated TaskNode nodes      = 7;
  repeated TaskEdge edges      = 8;
}

message CreateTaskResp {
  string id = 1;
}

message NonceRequest {
  string owner = 1;
}

message NonceResp {
  string nonce = 1;
}

message ListWalletReq {
  // filter out by factory address or salt
  // otherwise return all the wallet
  string factory_address = 1; // TODO: Consider renaming to factoryAddress for consistency if this is used as a filter key matching SmartWallet.factoryAddress
  string salt            = 2;
}

message SmartWallet {
  string address = 1;
  string salt = 2;
  string factory = 3;
  bool is_hidden = 4;  // Whether the wallet is hidden
}

message ListWalletResp {
  repeated SmartWallet items = 1;
}


message ListTasksReq {
  // Filter out by the smart_wallet_address
  repeated string smart_wallet_address = 1;
  // Get items before this cursor value (for backward pagination)
  string before = 2;
  // Get items after this cursor value (for forward pagination)
  string after = 3;
  int64 limit = 4;
  
  // Field control options for flexible response content
  bool include_nodes = 5;  // Include task nodes (expensive field)
  bool include_edges = 6;  // Include task edges (expensive field)
}

message ListTasksResp {
  repeated Task items = 1;
  PageInfo page_info = 2;
}

message ListExecutionsReq {
  repeated string task_ids = 1;
  // Get items before this cursor value (for backward pagination)
  string before = 2;
  // Get items after this cursor value (for forward pagination)
  string after = 3;
  int64 limit = 4;
}

message ListExecutionsResp {
  repeated Execution items = 1;
  PageInfo page_info = 2;
}

message ExecutionReq {
  string task_id = 1;
  string execution_id = 2;
}

message ExecutionStatusResp {
  ExecutionStatus status = 1;
}

message GetKeyReq {
  // The message to sign, provided by GetSignatureFormat
  string message = 1;
  // The signature of the message
  string signature = 2;
}

message KeyResp {
  // The user's address derived from the signature
  string address = 1;
  
  // The auth key to include in all future requests
  string key = 2;
  
  // The message that was signed to produce the signature
  string message = 3;
  
  // Expiry of the auth key in seconds since epoch
  uint64 expiry = 4;
}

message GetWalletReq {
  string salt = 1;
  // this is the factory address for the wallet, when leaving its empty, we will use our default factory address
  string factory_address = 2;
}

message GetWalletResp {
  string address = 1;
  string salt = 2;
  string factory_address = 3;
  bool is_hidden = 4;
  uint64 total_task_count = 5;
  uint64 active_task_count = 6;
  uint64 completed_task_count = 7;
  uint64 failed_task_count = 8;
  uint64 canceled_task_count = 9;
}

message SetWalletReq {
  string salt = 1;
  // this is the factory address for the wallet, when leaving its empty, we will use our default factory address
  string factory_address = 2;
  // whether the wallet should be hidden in getWallets results
  bool is_hidden = 3;
}

message TriggerTaskReq {
  string task_id = 1;
  
  // Flattened from TriggerReason: Use the top-level TriggerType enum for consistency
  TriggerType trigger_type = 2;

  // Flattened from TriggerReason: trigger output data based on type
  oneof trigger_output {
    BlockTrigger.Output block_trigger = 3;
    FixedTimeTrigger.Output fixed_time_trigger = 4;
    CronTrigger.Output cron_trigger = 5;
    EventTrigger.Output event_trigger = 6;
    ManualTrigger.Output manual_trigger = 7;
  }
  
  // when setting is_blocking=true, the execution run in the same request. the request is blocked until the execution is done
  // setting to false, the task will be execute in our normal queueu system, and the request won't block.
  // default value is false, for interact testing, set this to true
  bool is_blocking = 8;
}

message TriggerTaskResp {
  // Regardless whether it is a block or async, we always get back the same kind of id for this trigger.
  // The caller then make a second request to GetExecution to check for the execution status and data.
  // In the blocking mode, the execution_id is materialized and has been created, we can then call GetExecution on it immediately to receive result
  // In async mode, the execution_id is created ahead of time and not materialized, calling GetExecutionStatus on it will return Status=Pending for example. Once Status=Completed you can call GetExecution to get all log and detail. Call GetExecution before it is completed will result in "Execution Not Found"
  string execution_id = 1;
  ExecutionStatus status = 2;
}

message CreateOrUpdateSecretReq {
  // name of the secret. it should be [a-zA-Z0-9_]+
  string name = 1;

  // value can be any valid unicode string
  // Secret is the only thing we can change in an update. workflow and org id cannot be change
  string secret = 2;

  // A secret when define can be at these level
  // - org: available to everything in the org. Currently this isn't supported yet. reserve for future use
  // - user: available to all workflow of an user. This is the default level
  // - workflow: available to a single workflow. To make a secret available to multiple workflow, either use org/user level or define them on other workflow.
  string workflow_id = 3;
  string org_id = 4;
}

message ListSecretsReq {
  string workflow_id = 1;
  // Get items before this cursor value (for backward pagination)
  string before = 2;
  // Get items after this cursor value (for forward pagination)
  string after = 3;
  int64 limit = 4;
  
  // Field control options for flexible response content
  bool include_timestamps = 5;   // Include created_at and updated_at fields
  bool include_created_by = 6;   // Include created_by field
  bool include_description = 7;  // Include description field
}

// Standard pagination info following GraphQL cursor-based pagination
message PageInfo {
  string start_cursor = 1;     // Cursor pointing to the first item in the current page
  string end_cursor = 2;       // Cursor pointing to the last item in the current page
  bool has_previous_page = 3;  // Whether there are more items before the current page
  bool has_next_page = 4;      // Whether there are more items after the current page
}

// Secret represents a secret configuration without the actual secret value
message Secret {
  // when listing secret, we don't return its value, just secret and last update
  string name = 1;
  string scope = 2;
  string workflow_id = 3;
  string org_id = 4;
  // Additional fields that can be controlled via field masks
  int64 created_at = 5;      // Unix timestamp when secret was created
  int64 updated_at = 6;      // Unix timestamp when secret was last updated
  string created_by = 7;     // User ID who created the secret
  string description = 8;    // Optional description of the secret
}

message ListSecretsResp {
  repeated Secret items = 1;
  PageInfo page_info = 2;
}

message DeleteSecretReq {
  string name = 1;

  // Delete the secret belong to the specific workflow. Without its, we delete the one belong to user
  string workflow_id = 2;

  // Delete the secret belong to the specific prg. Without its, we delete the one belong to user
  string org_id = 3;
}

// Response message for DeleteSecret operation
message DeleteSecretResp {
  bool success = 1;                    // Whether the operation completed successfully
  string status = 2;                   // Status description: "deleted", "not_found", "already_deleted"
  string message = 3;                  // Human-readable message about what happened
  int64 deleted_at = 4;                // Unix timestamp when the secret was deleted (if applicable)
  string secret_name = 5;              // Name of the secret that was affected
  string scope = 6;                    // Scope of the deleted secret: "user", "workflow", "org"
}

message GetSignatureFormatReq {
  // The wallet address to include in the signature format
  string wallet = 1;
}

message GetSignatureFormatResp {
  // The formatted signature message with server-side values filled in
  string message = 1;
}

// Response message for CreateSecret operation
message CreateSecretResp {
  bool success = 1;                    // Whether the operation completed successfully
  string status = 2;                   // Status description: "created", "already_exists", "error"
  string message = 3;                  // Human-readable message about what happened
  int64 created_at = 4;                // Unix timestamp when the secret was created (if applicable)
  string secret_name = 5;              // Name of the secret that was affected
  string scope = 6;                    // Scope of the created secret: "user", "workflow", "org"
}

// Response message for UpdateSecret operation
message UpdateSecretResp {
  bool success = 1;                    // Whether the operation completed successfully
  string status = 2;                   // Status description: "updated", "not_found", "error"
  string message = 3;                  // Human-readable message about what happened
  int64 updated_at = 4;                // Unix timestamp when the secret was updated (if applicable)
  string secret_name = 5;              // Name of the secret that was affected
  string scope = 6;                    // Scope of the updated secret: "user", "workflow", "org"
}

// Response message for DeleteTask operation  
message DeleteTaskResp {
  bool success = 1;                    // Whether the operation completed successfully
  string status = 2;                   // Status description: "deleted", "not_found", "cannot_delete"
  string message = 3;                  // Human-readable message about what happened
  int64 deleted_at = 4;                // Unix timestamp when the task was deleted (if applicable)
  string id = 5;                  // ID of the task that was affected
  string previous_status = 6;          // Previous status of the task before deletion
}

// Response message for CancelTask operation  
message CancelTaskResp {
  bool success = 1;                    // Whether the operation completed successfully
  string status = 2;                   // Status description: "cancelled", "not_found", "already_cancelled", "cannot_cancel"
  string message = 3;                  // Human-readable message about what happened
  int64 cancelled_at = 4;              // Unix timestamp when the task was cancelled (if applicable)
  string id = 5;                  // ID of the task that was affected
  string previous_status = 6;          // Previous status of the task before cancellation
}

service Aggregator {
  // Exchange for an Auth Key to authenticate in subsequent request
  rpc GetKey(GetKeyReq) returns (KeyResp) {};
  
  // Get the signature format template used for authentication
  rpc GetSignatureFormat(GetSignatureFormatReq) returns (GetSignatureFormatResp) {};

  // Smart Acccount Operation
  rpc GetNonce(NonceRequest)        returns (NonceResp) {};
  rpc GetWallet(GetWalletReq)       returns (GetWalletResp) {};
  rpc SetWallet(SetWalletReq)       returns (GetWalletResp) {};
  rpc ListWallets(ListWalletReq)    returns (ListWalletResp) {};

  
  // Task Management Operation
  rpc CreateTask(CreateTaskReq)         returns (CreateTaskResp) {};
  rpc ListTasks(ListTasksReq)           returns (ListTasksResp) {};
  rpc GetTask(IdReq)                    returns (Task) {};
  rpc ListExecutions(ListExecutionsReq) returns (ListExecutionsResp) {};

  rpc GetExecution(ExecutionReq)     returns (Execution) {};
  rpc GetExecutionStatus(ExecutionReq)     returns (ExecutionStatusResp) {};

  rpc CancelTask(IdReq)                 returns (CancelTaskResp) {};
  rpc DeleteTask(IdReq)                 returns (DeleteTaskResp) {};
  rpc TriggerTask(TriggerTaskReq)   returns (TriggerTaskResp) {};

  // CreateSecret allow you to define a secret to be used in your tasks. The secret can be used with a special syntax of ${{secrets.name }}.
  // You can decide whether to grant secret to a single workflow or many workflow, or all of your workflow
  // By default, your secret is available across all of your tasks.
  rpc CreateSecret(CreateOrUpdateSecretReq) returns (CreateSecretResp) {};
  rpc DeleteSecret(DeleteSecretReq) returns (DeleteSecretResp) {};

  // Return all secrets belong to this user. Currently we don't support any fine tune or filter yet.
  // Only secret names and config data are returned. The secret value aren't returned.
  rpc ListSecrets(ListSecretsReq) returns (ListSecretsResp) {};

  // For simplicity, currently only the user who create the secrets can update its value, or update its permission.
  // The current implementation is also limited, update is an override action, not an appending action. So when updating, you need to pass the whole payload
  rpc UpdateSecret(CreateOrUpdateSecretReq) returns (UpdateSecretResp) {};

  // The spec of these 2 RPCs are based on the following issue:
  // Reference: https://github.com/AvaProtocol/EigenLayer-AVS/issues/150
  // GetWorkflowCount returns the total count of workflows for the given eoa addresses or a list of smart wallet addresses belongs to the eoa in the auth key
  // When passing a list of smart wallet addresses, we will return the total count of workflows belongs to all of them
  // If the smart wallet address is not found in our system, we will ignore it and not count towards the total
  // if smart wallet address doesn't belong to the eoa in the auth key, we will also ignore it and not count towards the total
  rpc GetWorkflowCount(GetWorkflowCountReq) returns (GetWorkflowCountResp);

  // GetExecutionCount returns the total number of executions for specified workflow IDs or all workflows linked to the EOA in the auth key.
  // If no workflow IDs are provided, it counts executions for all workflows of the EOA.
  // Workflow IDs not found in the system are ignored.
  // Workflow IDs not linked to the EOA in the auth key are also ignored.
  rpc GetExecutionCount(GetExecutionCountReq) returns (GetExecutionCountResp);

  // GetExecutionStats returns execution statistics for a specified time period
  // It counts total executions, successful executions, and failed executions
  // If no workflow IDs are provided, it counts for all workflows of the authenticated user
  rpc GetExecutionStats(GetExecutionStatsReq) returns (GetExecutionStatsResp);

  // RunNodeWithInputs allows executing a single node with provided inputs for testing purposes
  rpc RunNodeWithInputs(RunNodeWithInputsReq) returns (RunNodeWithInputsResp);
  
  // RunTrigger allows executing a single trigger for testing purposes
  rpc RunTrigger(RunTriggerReq) returns (RunTriggerResp);
  
  // SimulateTask allows executing a complete task simulation including trigger and all workflow nodes
  rpc SimulateTask(SimulateTaskReq) returns (Execution);
  
  // GetTokenMetadata allows looking up ERC20 token metadata by contract address
  rpc GetTokenMetadata(GetTokenMetadataReq) returns (GetTokenMetadataResp);
  

}

// Request message for GetWorkflowCount
message GetWorkflowCountReq {
  repeated string addresses = 1; // Optional array of smart wallet addresses
}

// Response message for GetWorkflowCount
message GetWorkflowCountResp {
  // TODO: eventually to support active, cancel and other metrics
  int64 total = 1; // the total count of workflow
}

message GetExecutionCountReq {
  repeated string workflow_ids = 1; // Optional array of workflow IDs, count all executions of the owner if not provided
}

// Response message for GetExecutionCount
message GetExecutionCountResp {
  // TODO: eventually to support success, error count execution
  int64 total = 1; // The total count of executions
}

// Request message for GetExecutionStats
message GetExecutionStatsReq {
  repeated string workflow_ids = 1; // Optional array of workflow IDs
  int64 days = 2; // Number of days to look back (default: 7)
}

// Response message for GetExecutionStats
message GetExecutionStatsResp {
  int64 total = 1; // Total number of executions
  int64 succeeded = 2; // Number of successful executions
  int64 failed = 3; // Number of failed executions
  double avg_execution_time = 4; // Average execution time in milliseconds
}

// Request message for RunNodeWithInputs
message RunNodeWithInputsReq {
  NodeType node_type = 1; // Type of node to execute using the NodeType enum
  map<string, google.protobuf.Value> node_config = 2; // Configuration for the node
  map<string, google.protobuf.Value> input_variables = 3; // Input variables for the node
}

// Response message for RunNodeWithInputs
message RunNodeWithInputsResp {
  bool success = 1; // Whether the execution was successful
  string error = 3; // Error message if execution failed
  string node_id = 4; // ID of the executed node
  google.protobuf.Value metadata = 5; // Optional structured metadata for testing/debugging
  
  // Use specific output types for nodes only
  oneof output_data {
    // Node outputs
    ETHTransferNode.Output eth_transfer = 10;
    GraphQLQueryNode.Output graphql = 11;
    ContractReadNode.Output contract_read = 12;
    ContractWriteNode.Output contract_write = 13;
    CustomCodeNode.Output custom_code = 14;
    RestAPINode.Output rest_api = 15;
    BranchNode.Output branch = 16;
    FilterNode.Output filter = 17;
    LoopNode.Output loop = 18;
  }
}

// Request message for RunTrigger
message RunTriggerReq {
  TriggerType trigger_type = 1; // Type of trigger to execute using the TriggerType enum
  map<string, google.protobuf.Value> trigger_config = 2; // Configuration for the trigger
  map<string, google.protobuf.Value> trigger_input = 3; // Input data for the trigger
}

// Response message for RunTrigger
message RunTriggerResp {
  bool success = 1; // Whether the execution was successful
  string error = 2; // Error message if execution failed
  string trigger_id = 3; // ID of the executed trigger
  google.protobuf.Value metadata = 4; // Optional structured metadata for testing/debugging
  
  // Use specific output types for triggers
  oneof output_data {
    BlockTrigger.Output block_trigger = 10;
    FixedTimeTrigger.Output fixed_time_trigger = 11;
    CronTrigger.Output cron_trigger = 12;
    EventTrigger.Output event_trigger = 13;
    ManualTrigger.Output manual_trigger = 14;
  }
}



// Request message for SimulateTask
message SimulateTaskReq {
  // Complete task definition for simulation (no need to save to storage first)
  TaskTrigger trigger = 1; // The trigger configuration
  repeated TaskNode nodes = 2; // All workflow nodes
  repeated TaskEdge edges = 3; // All edges connecting the nodes
  map<string, google.protobuf.Value> input_variables = 6; // Input variables for the simulation
}

// EventCondition represents a condition to evaluate on decoded event data
message EventCondition {
  string field_name = 1;        // Event field name (e.g., "answer", "roundId")
  string operator = 2;          // Comparison operator: "gt", "gte", "lt", "lte", "eq", "ne"
  string value = 3;             // Value to compare against (as string, parsed based on type)
  string field_type = 4;        // Field type: "uint256", "int256", "address", "bool", "bytes32", etc.
}