name: Create GitHub Pre-Release on Staging Merge to Main

on:
  pull_request:
    types: [closed]
    branches:
      - main

jobs:
  release-and-publish:
    # Only run this job if the PR from staging was merged to main
    if: github.event.pull_request.merged == true && github.event.pull_request.head.ref == 'staging'
    runs-on: ubuntu-latest
    permissions:
      contents: write # Needed for go-semantic-release to create tags and releases
      packages: write # If you use GitHub Packages for Docker images (good to have)
    steps:
      - name: Checkout repository with full history
        uses: actions/checkout@v4
        with:
          # Fetch all history so go-semantic-release can determine the version based on all commits
          fetch-depth: 0
          # We need to check out the main branch itself after the merge, not the PR ref
          ref: main

      - name: Setup Go environment
        uses: actions/setup-go@v4
        with:
          go-version: '1.24' # Updated to match project's Go version

      # Optional: Add linting and testing steps here if you want to be absolutely sure
      # before a release, though these should ideally be covered by PR checks.
      # - name: Run Go linter
      #   uses: golangci/golangci-lint-action@v3
      #   with:
      #     version: latest
      # - name: Run Go tests
      #   run: go test -v ./...

      - name: Generate commit summary for changelog
        id: git-summary
        run: |
          echo "## Summary" > commit-summary.md
          echo "" >> commit-summary.md
          # Correctly get commits since the last full tag on the main branch
          LAST_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || git rev-list --max-parents=0 HEAD)
          echo "Last tag for changelog: $LAST_TAG"
          
          # Count different types of commits
          FEATURES=$(git log $LAST_TAG..HEAD --pretty=format:"%s" --no-merges | grep -i "^feat" | wc -l || echo "0")
          FIXES=$(git log $LAST_TAG..HEAD --pretty=format:"%s" --no-merges | grep -i "^fix" | wc -l || echo "0")
          DOCS=$(git log $LAST_TAG..HEAD --pretty=format:"%s" --no-merges | grep -i "^docs" | wc -l || echo "0")
          
          # Write summary
          echo "* $FEATURES new features" >> commit-summary.md
          echo "* $FIXES bug fixes" >> commit-summary.md
          echo "* $DOCS documentation updates" >> commit-summary.md
          echo "" >> commit-summary.md
          
          # Write detailed changes
          echo "## Changes since last release ($LAST_TAG)" >> commit-summary.md
          echo "" >> commit-summary.md
          git log $LAST_TAG..HEAD --pretty=format:"* %s (%h)" --no-merges >> commit-summary.md || echo "* No changes found" >> commit-summary.md
          
          # Set the environment variable using proper GitHub Actions syntax
          echo "COMMIT_SUMMARY<<EOF" >> $GITHUB_ENV
          cat commit-summary.md >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV
          
          # Debug: Print the summary to verify it was generated correctly
          echo "Generated commit summary:"
          cat commit-summary.md
        shell: bash

      - name: Run semantic versioning and create full release
        id: semantic-release
        uses: go-semantic-release/action@v1
        with:
          args: --prerelease # Create a pre-release
          # No pre-release flag needed; it should detect it's on main and do a full release
          hooks: goreleaser # Or other hooks you use for release asset generation
          changelog: ${{ env.COMMIT_SUMMARY }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
