name: Create GitHub Pre-Release on Staging Merge to Main

on:
  pull_request:
    types: [closed]
    branches:
      - main

jobs:
  release-and-publish:
    # Only run this job if the PR from staging was merged to main
    if: github.event.pull_request.merged == true && github.event.pull_request.head.ref == 'staging'
    runs-on: ubuntu-latest
    permissions:
      contents: write # Needed for go-semantic-release to create tags and releases
      packages: write # If you use GitHub Packages for Docker images (good to have)
    steps:
      - name: Checkout repository with full history
        uses: actions/checkout@v4
        with:
          # Fetch all history so go-semantic-release can determine the version based on all commits
          fetch-depth: 0
          # We need to check out the main branch itself after the merge, not the PR ref
          ref: main

      - name: Setup Go environment
        uses: actions/setup-go@v4
        with:
          go-version: '1.24' # Updated to match project's Go version

      # Optional: Add linting and testing steps here if you want to be absolutely sure
      # before a release, though these should ideally be covered by PR checks.
      # - name: Run Go linter
      #   uses: golangci/golangci-lint-action@v3
      #   with:
      #     version: latest
      # - name: Run Go tests
      #   run: go test -v ./...

      - name: Generate commit summary for changelog
        id: git-summary
        run: |
          # Create changelog in semantic-release format
          echo "# Changelog" > commit-summary.md
          echo "" >> commit-summary.md
          
          # Get the last tag
          LAST_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || git rev-list --max-parents=0 HEAD)
          echo "Last tag for changelog: $LAST_TAG"
          
          # Count different types of commits
          FEATURES=$(git log $LAST_TAG..HEAD --pretty=format:"%s" --no-merges | grep -i "^feat" | wc -l || echo "0")
          FIXES=$(git log $LAST_TAG..HEAD --pretty=format:"%s" --no-merges | grep -i "^fix" | wc -l || echo "0")
          DOCS=$(git log $LAST_TAG..HEAD --pretty=format:"%s" --no-merges | grep -i "^docs" | wc -l || echo "0")
          
          # Write summary in semantic-release format
          echo "## Summary" >> commit-summary.md
          echo "" >> commit-summary.md
          echo "- Features: $FEATURES" >> commit-summary.md
          echo "- Bug Fixes: $FIXES" >> commit-summary.md
          echo "- Documentation: $DOCS" >> commit-summary.md
          echo "" >> commit-summary.md
          
          # Write detailed changes in semantic-release format
          echo "## Changes" >> commit-summary.md
          echo "" >> commit-summary.md
          
          # Group commits by type
          if [ "$FEATURES" -gt 0 ]; then
            echo "### Features" >> commit-summary.md
            echo "" >> commit-summary.md
            git log $LAST_TAG..HEAD --pretty=format:"- %s (%h)" --no-merges | grep -i "^feat" >> commit-summary.md
            echo "" >> commit-summary.md
          fi
          
          if [ "$FIXES" -gt 0 ]; then
            echo "### Bug Fixes" >> commit-summary.md
            echo "" >> commit-summary.md
            git log $LAST_TAG..HEAD --pretty=format:"- %s (%h)" --no-merges | grep -i "^fix" >> commit-summary.md
            echo "" >> commit-summary.md
          fi
          
          if [ "$DOCS" -gt 0 ]; then
            echo "### Documentation" >> commit-summary.md
            echo "" >> commit-summary.md
            git log $LAST_TAG..HEAD --pretty=format:"- %s (%h)" --no-merges | grep -i "^docs" >> commit-summary.md
            echo "" >> commit-summary.md
          fi
          
          # Other changes
          OTHER_CHANGES=$(git log $LAST_TAG..HEAD --pretty=format:"%s" --no-merges | grep -E -v -i "^(feat|fix|docs)" | wc -l || echo "0")
          if [ "$OTHER_CHANGES" -gt 0 ]; then
            echo "### Other Changes" >> commit-summary.md
            echo "" >> commit-summary.md
            git log $LAST_TAG..HEAD --pretty=format:"- %s (%h)" --no-merges | grep -E -v -i "^(feat|fix|docs)" >> commit-summary.md
            echo "" >> commit-summary.md
          fi
          
          # Set the environment variable
          # First, create a temporary file with the content
          cat commit-summary.md > /tmp/changelog.txt
          
          # Then set the environment variable using GitHub's file command
          echo "COMMIT_SUMMARY<<EOF" >> $GITHUB_ENV
          cat /tmp/changelog.txt >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV
          
          # Debug: Print the summary
          echo "Generated commit summary:"
          cat commit-summary.md
          
          # Debug: Print the environment variable setting
          echo "Setting environment variable with content length: $(wc -l < /tmp/changelog.txt) lines"
        shell: bash

      - name: Run semantic versioning and create full release
        id: semantic-release
        uses: go-semantic-release/action@v1
        with:
          args: --prerelease # Create a pre-release
          # No pre-release flag needed; it should detect it's on main and do a full release
          hooks: goreleaser # Or other hooks you use for release asset generation
          changelog: ${{ env.COMMIT_SUMMARY }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
